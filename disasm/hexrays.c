/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void __cdecl __noreturn start(int, int); // weak
int __cdecl sub_134(int a1);
int __cdecl sub_184(char a1);
int __cdecl sub_274(_BYTE **a1, unsigned __int8 *a2, char *a3, int a4);
_BOOL4 __cdecl sub_304(char *a1, const char *a2, const char *a3, int a4);
char __cdecl sub_3F4(const char *a1);
int sub_437(); // weak
int __cdecl sub_444(int a1);
int __cdecl sub_4C4(_BYTE *a1);
int __cdecl sub_564(int a1, int *a2);
int __cdecl sub_BC4(int d, int a2); // idb
_BYTE *__cdecl sub_C68(unsigned __int8 *a1, char *a2, unsigned int a3, unsigned __int8 a4, int a5);
int __cdecl sub_D08(_BYTE *a1, _BYTE *a2, int a3);
void __cdecl sub_D38(unsigned __int8 *a1, char *a2, unsigned __int8 a3);
int __cdecl sub_DD0(char *a1, unsigned __int8 a2);
char __cdecl sub_E00(int a1, char *a2, unsigned __int8 a3, unsigned __int8 a4, unsigned int a5);
_BYTE *__cdecl sub_E50(_BYTE *a1, _BYTE *a2);
int __cdecl sub_F60(int a1, unsigned __int8 *a2);
_BYTE *__cdecl sub_FA0(_BYTE **a1, int a2, unsigned int a3, int a4);
_BYTE *__cdecl sub_1100(_BYTE *a1, unsigned int *a2);
int __cdecl sub_1140(int *a1, unsigned __int8 *a2);
int __cdecl sub_11A0(unsigned int *a1, _DWORD *a2);
int __cdecl sub_1450(unsigned int *a1, unsigned int a2, unsigned int a3);
unsigned int __cdecl sub_1760(unsigned int a1, unsigned __int8 *a2);
_BYTE *__cdecl sub_1830(_BYTE *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_18A0(_BYTE *a1, _BYTE *a2, _BYTE *a3, int a4);
unsigned int __cdecl sub_18D0(char *a1, _BYTE *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, int a6, int a7);
int sub_1A8C();
int sub_1ACC();
long double sub_1AEC();
int __cdecl sub_1B3C(unsigned __int16 *a1);
unsigned int sub_1B9C();
int sub_1BBC();
void *sub_1BDC();
unsigned int __cdecl sub_1D1C(unsigned int a1);
unsigned int __cdecl sub_1E3C(unsigned __int16 *a1);
int __cdecl sub_1E9C(unsigned __int16 *a1);
int __cdecl sub_1EFC(int a1);
int sub_1F2C();
int __cdecl sub_1FC4(int a1, char *a2, unsigned int a3);
int __cdecl sub_2000(int a1, char *a2);
int __cdecl sub_2020(int signum, int a2); // idb
__int16 __cdecl sub_206C(__int16 a1);
int __cdecl sub_20AC(int a1, unsigned __int8 a2, unsigned int a3);
const char *__cdecl sub_20F8(const char *a1, char *a2);
int __cdecl sub_211C(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_2148(int a1);
int sub_2188();
int __cdecl sub_2218(int a1);
int __cdecl sub_2378(unsigned int a1);
void __cdecl sub_26E8(_DWORD *a1);
int __cdecl sub_29F4(int a1, int a2, int a3);
int __cdecl sub_2A30(int signum, const struct sigaction *act, struct sigaction *old); // idb
unsigned __int8 *__cdecl sub_2E94(char *a1);
int __cdecl sub_2EF4(int a1);
// int __usercall sub_3124@<eax>(_BYTE *a1@<ebp>, int a2, int *a3, char *a4, const char **a5, _DWORD *a6, int a7);
// int __usercall sub_39F4@<eax>(_BYTE *a1@<ebp>, int a2, int *a3, char *a4);
void __cdecl __noreturn sub_3A14(int status); // idb
void __cdecl __noreturn sub_3A84(int status); // idb
int __cdecl sub_3AB4(const char *libname); // idb
int __cdecl sub_3AE4(int fd, const void *addr, size_t len); // idb
int __cdecl sub_3B24(void *addr, int len); // idb
void __cdecl sub_3BA4(int a1, const void **a2, int a3);
void __cdecl __noreturn sub_3CF0(int status); // idb
int sub_3D50(); // weak
// int __usercall sub_3D60@<eax>(_BYTE *a1@<ebp>, char *a2, int a3);
int *__cdecl sub_40B0(int a1, int a2);
int *__cdecl sub_41B0(_DWORD *a1, int a2);
int __cdecl sub_4290(int a1, int a2, int a3, int a4);
void __cdecl sub_42D0(int a1);
// int __usercall sub_43C0@<eax>(off_t a1@<ebp>, char *filename, int a3, int a4);
int __cdecl sub_45F0(int a1, _DWORD *a2);
// void __usercall sub_4734(_BYTE *a1@<ebp>);
void __cdecl sub_4760(char *a1, int a2, int a3);
int __cdecl sub_5524(int a1);
char *__cdecl sub_5554(char *a1, char a2);
int __cdecl sub_5578(int fd); // idb
int sub_5598();
int __cdecl sub_55B8(int d, int request);
int __cdecl sub_55E0(pid_t pid, int sig); // idb
int __cdecl sub_5604(char *filename, int flags, mode_t mode); // idb
int __cdecl sub_562C(int fd, void *addr, size_t len); // idb
int __cdecl sub_5654(const char *path, struct stat *buf); // idb
int __cdecl sub_5678(int fd, const void *addr, size_t len); // idb
int __cdecl sub_56A0(void *addr, int len); // idb
int sub_5728(); // weak
char *__cdecl sub_5744(int a1, unsigned __int8 *a2);
// int __usercall sub_5E74@<eax>(size_t a1@<ecx>, off_t a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl sub_5ED8(int a1);
int __cdecl sub_5EF8(int a1);
void __cdecl sub_5FA8(_BYTE *a1);
unsigned int *__cdecl sub_5FC8(unsigned int *a1, char *filename, char *a3);
_DWORD *__cdecl sub_60E8(_DWORD *a1, int a2);
int __cdecl sub_6168(_DWORD *a1, int a2, int a3);
int __cdecl sub_61B8(int a1, unsigned int a2, int a3);
int __cdecl sub_6298(int a1);
int __cdecl sub_6358(int a1, int a2);
int __cdecl sub_6468(_DWORD *a1);
int __cdecl sub_64C8(int a1, int a2, char a3);
int __cdecl sub_66A8(int a1, void *addr, size_t len); // idb
int __cdecl sub_6738(int a1, char *addr, size_t len);
unsigned int __cdecl sub_6798(_DWORD *a1, char *a2, unsigned int a3);
void __cdecl sub_6900(char *a1);
int __cdecl sub_6950(int a1);
int __cdecl sub_6970(_DWORD *a1);
_DWORD *__cdecl sub_69A0(_DWORD *a1);
_DWORD *__cdecl sub_69D0(_DWORD *a1);
int __cdecl sub_6A00(int a1);
void __cdecl sub_6A70(int a1);
int __cdecl sub_6AB0(int a1, int a2);
int __cdecl sub_6AD0(int a1);
int __cdecl sub_6CE0(int a1, int a2, int a3, int a4);
void __cdecl sub_6D30(int a1);
int sub_6D70();
unsigned int __cdecl sub_6D80(int a1, char *a2, unsigned int a3);
unsigned int __cdecl sub_6E50(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_6F10(_DWORD *a1, int a2, int a3);
int __cdecl sub_7010(int a1, int a2);
int sub_7090();
void __cdecl sub_70A0(int a1);
int sub_70F0();
int __cdecl sub_7100(_DWORD *a1, int a2);
int __cdecl sub_7160(int a1, __int16 a2);
int __cdecl sub_7180(int a1, unsigned int a2, int a3);
int sub_71F0();
int sub_7230();
int __cdecl sub_7260(_DWORD *a1, int a2);
int __cdecl sub_72E0(int a1, int a2);
int __cdecl sub_7330(int a1, int a2);
void __cdecl sub_7390(int a1);
int __cdecl sub_73E0(int a1, int a2);
int sub_74E0();
int sub_74F0();
int sub_7500();
int sub_7510();
int sub_7514(_DWORD *a1, int a2, ...);
int __cdecl sub_7564(const char *a1, _DWORD *a2);
int sub_75DC(const char *a1, int a2, ...);
int sub_75F4(const char *a1, unsigned __int8 *a2, ...);
int __cdecl sub_760C(_DWORD *a1, unsigned __int8 a2);
int __cdecl sub_767C(int a1, int a2, int a3);
int __cdecl sub_775C(_DWORD *a1, int a2, int a3);
int __cdecl sub_806C(const char *a1, int a2, int a3);
int __cdecl sub_80E0(const char *a1, unsigned __int8 *a2, int a3);
// int __usercall sub_8128@<eax>(int a1@<ebp>, double a2, _DWORD *a3, int a4, int a5, int a6, unsigned int a7, int a8, int a9);
int __cdecl sub_8778(_DWORD *a1, const char *a2, int a3, int a4);
int __cdecl sub_8828(_DWORD *a1, const char *a2, int a3);
int __cdecl sub_8848(int a1, int a2);
unsigned int __cdecl sub_89E8(_DWORD *a1);
int __cdecl sub_8A08(_DWORD *a1, int a2, char a3);
void __cdecl sub_8AE8(int a1);
int __cdecl sub_8B18(int a1);
int __cdecl sub_8B50(int a1, char *a2, unsigned int a3);
int __cdecl sub_8BD4(int a1);
_BYTE *__cdecl sub_8C0C(_BYTE *a1, unsigned __int8 a2, int a3);
int __cdecl sub_8C40(unsigned __int8 *a1, unsigned __int8 *a2);
int __cdecl sub_8C64(int fd, struct stat *buf); // idb
int __cdecl sub_8C88(int fd, off_t offset, int whence); // idb
int __cdecl sub_8CC0(_DWORD *a1);
int __cdecl sub_8D5C(int a1);
int __cdecl sub_8D8C(int a1);
void __cdecl sub_8DDC(int a1);
_DWORD *__cdecl sub_8DFC(int a1, int a2);
int __cdecl sub_8E2C(int a1, int a2);
int __cdecl sub_8E8C(_DWORD *a1, int a2, unsigned int a3);
_DWORD *__cdecl sub_8F1C(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8FDC(int a1);
int __cdecl sub_904C(unsigned int *a1);
int __cdecl sub_90DC(int a1, int a2);
int __cdecl sub_90FC(int a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_92CC(_DWORD *a1, int a2);
_DWORD *__cdecl sub_932C(_DWORD *a1, int a2);
int __cdecl sub_946C(int a1, int a2);
int __cdecl sub_94CC(int a1, int a2, int a3);
long double __cdecl sub_965C(int a1, int a2);
long double __cdecl sub_96FC(int a1, _DWORD *a2);
_DWORD *__cdecl sub_980C(int a1, unsigned int a2, int a3, _DWORD *a4, _DWORD *a5);
long double __cdecl sub_997C(int a1, int a2);
long double __cdecl sub_9A1C(_BYTE *a1, _DWORD *a2);
unsigned int __cdecl sub_A8CC(int a1, int a2);
char *__cdecl sub_AB3C(double a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
int __cdecl sub_BC04(int a1, int a2, int a3);
int __cdecl sub_BC9C(_DWORD *a1, unsigned __int8 *a2, int a3, _BYTE *a4);
unsigned __int8 *__cdecl sub_CCCC(int a1, unsigned __int8 *a2);
int __cdecl sub_CD8C(char *a1, char **a2, int a3);
int __cdecl sub_D008(char *a1, char **a2, int a3);
int __cdecl sub_D254(int how, const struct sigaction *act, struct sigaction *oldact); // idb
int __cdecl sub_D27C(int a1, _DWORD *a2);
_BOOL4 __cdecl sub_D2D4(int d);
int __cdecl sub_D308(int d);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_510; // weak
char byte_511[3] = { ':', '\0', 'M' }; // weak
_UNKNOWN loc_330A; // weak
_UNKNOWN unk_3D00; // weak
int dword_4724[4] = { 1651076096, -1869610909, -1869574000, -1869574000 }; // weak
char *off_4810[122] =
{
  "Unknown error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted system call",
  "I/O error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file number",
  "No child processes",
  "Try again",
  "Out of memory",
  "Permission denied",
  "Bad address",
  "Block device required",
  "Device or resource busy",
  "File exists",
  "Cross-device link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "File table overflow",
  "Too many open files",
  "Not a typewriter",
  "Text file busy",
  "File too large",
  "No space left on device",
  "Illegal seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Math argument out of domain of func",
  "Math result not representable",
  "Resource deadlock would occur",
  "File name too long",
  "No record locks available",
  "Function not implemented",
  "Directory not empty",
  "Too many symbolic links encountered",
  "Operation would block",
  "No message of desired type",
  "Identifier removed",
  "Channel number out of range",
  "Level 2 not synchronized",
  "Level 3 halted",
  "Level 3 reset",
  "Link number out of range",
  "Protocol driver not attached",
  "No CSI structure available",
  "Level 2 halted",
  "Invalid exchange",
  "Invalid request descriptor",
  "Exchange full",
  "No anode",
  "Invalid request code",
  "Invalid slot",
  "File locking deadlock error",
  "Bad font file format",
  "Device not a stream",
  "No data available",
  "Timer expired",
  "Out of streams resources",
  "Machine is not on the network",
  "Package not installed",
  "Object is remote",
  "Link has been severed",
  "Advertise error",
  "Srmount error",
  "Communication error on send",
  "Protocol error",
  "Multihop attempted",
  "RFS specific error",
  "Not a data message",
  "Value too large for defined data type",
  "Name not unique on network",
  "File descriptor in bad state",
  "Remote address changed",
  "Can not access a needed shared library",
  "Accessing a corrupted shared library",
  ".lib section in a.out corrupted",
  "Attempting to link in too many shared libraries",
  "Cannot exec a shared library directly",
  "Illegal byte sequence",
  "Interrupted system call should be restarted",
  "Streams pipe error",
  "Too many users",
  "Socket operation on non-socket",
  "Destination address required",
  "Message too long",
  "Protocol wrong type for socket",
  "Protocol not available",
  "Protocol not supported",
  "Socket type not supported",
  "Operation not supported on transport endpoint",
  "Protocol family not supported",
  "Address family not supported by protocol",
  "Address already in use",
  "Cannot assign requested address",
  "Network is down",
  "Network is unreachable",
  "Network dropped connection because of reset",
  "Software caused connection abort",
  "Connection reset by peer",
  "No buffer space available",
  "Transport endpoint is already connected",
  "Transport endpoint is not connected",
  "Cannot send after transport endpoint shutdown",
  "Too many references: cannot splice",
  "Connection timed out",
  "Connection refused",
  "Host is down",
  "No route to host",
  "Operation already in progress",
  "Operation now in progress",
  "Stale NFS file handle",
  "Structure needs cleaning",
  "Not a XENIX named type file",
  "No XENIX semaphores available",
  "Is a named type file",
  "Remote I/O error"
}; // weak
_UNKNOWN loc_572D; // weak
int dword_BBE4[8] =
{
  538976288,
  538976288,
  538976288,
  538976288,
  808464432,
  808464432,
  808464432,
  808464432
}; // weak
int dword_DEEC[69] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_E000[3] = { -18145581, 248, 240 }; // weak
char *off_E00C[3] =
{
  "DLD - Deutsche Linux Distribution -\nGebrauch: dldkey -k <key>",
  "Error: invalid activationkey",
  "No, no!"
}; // weak
unsigned __int8 byte_E0A4[72] =
{
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  57u,
  49u,
  41u,
  33u,
  25u,
  17u,
  9u,
  1u,
  58u,
  50u,
  42u,
  34u,
  26u,
  18u,
  10u,
  2u,
  59u,
  51u,
  43u,
  35u,
  27u,
  19u,
  11u,
  3u,
  60u,
  52u,
  44u,
  36u,
  63u,
  55u,
  47u,
  39u,
  31u,
  23u,
  15u,
  7u,
  62u,
  54u,
  46u,
  38u,
  30u,
  22u,
  14u,
  6u,
  61u,
  53u,
  45u,
  37u,
  29u,
  21u,
  13u,
  5u,
  28u,
  20u,
  12u,
  4u
}; // weak
int dword_E0EC[64] =
{
  8421888,
  0,
  32768,
  8421890,
  8421378,
  33282,
  2,
  32768,
  512,
  8421888,
  8421890,
  512,
  8389122,
  8421378,
  8388608,
  2,
  514,
  8389120,
  8389120,
  33280,
  33280,
  8421376,
  8421376,
  8389122,
  32770,
  8388610,
  8388610,
  32770,
  0,
  514,
  33282,
  8388608,
  32768,
  8421890,
  2,
  8421376,
  8421888,
  8388608,
  8388608,
  512,
  8421378,
  32768,
  33280,
  8388610,
  512,
  2,
  8389122,
  33282,
  8421890,
  32770,
  8421376,
  8389122,
  8388610,
  514,
  33282,
  8421888,
  514,
  8389120,
  8389120,
  0,
  32770,
  33280,
  0,
  8421378
}; // weak
int dword_E1EC[64] =
{
  1074282512,
  1073758208,
  16384,
  540688,
  524288,
  16,
  1074266128,
  1073758224,
  1073741840,
  1074282512,
  1074282496,
  1073741824,
  1073758208,
  524288,
  16,
  1074266128,
  540672,
  524304,
  1073758224,
  0,
  1073741824,
  16384,
  540688,
  1074266112,
  524304,
  1073741840,
  0,
  540672,
  16400,
  1074282496,
  1074266112,
  16400,
  0,
  540688,
  1074266128,
  524288,
  1073758224,
  1074266112,
  1074282496,
  16384,
  1074266112,
  1073758208,
  16,
  1074282512,
  540688,
  16,
  16384,
  1073741824,
  16400,
  1074282496,
  524288,
  1073741840,
  524304,
  1073758224,
  1073741840,
  524304,
  540672,
  0,
  1073758208,
  16400,
  1073741824,
  1074266128,
  1074282512,
  540672
}; // weak
_UNKNOWN *off_E2EC = (_UNKNOWN *)0x104; // weak
int dword_E3EC[64] =
{
  -2143285248,
  -2147479488,
  -2147479488,
  64,
  4198464,
  -2143289280,
  -2143289344,
  -2147479552,
  0,
  4198400,
  4198400,
  -2143285184,
  -2147483584,
  0,
  4194368,
  -2143289344,
  2147483648,
  4096,
  4194304,
  -2143285248,
  64,
  4194304,
  -2147479552,
  4160,
  -2143289280,
  2147483648,
  4160,
  4194368,
  4096,
  4198464,
  -2143285184,
  -2147483584,
  4194368,
  -2143289344,
  4198400,
  -2143285184,
  -2147483584,
  0,
  0,
  4198400,
  4160,
  4194368,
  -2143289280,
  2147483648,
  -2143285248,
  -2147479488,
  -2147479488,
  64,
  -2143285184,
  -2147483584,
  2147483648,
  4096,
  -2143289344,
  -2147479552,
  4198464,
  -2143289280,
  -2147479552,
  4160,
  4194304,
  -2143285248,
  64,
  4194304,
  4096,
  4198464
}; // weak
char *off_E4EC = "key -k <key>"; // weak
int dword_E5EC[32] =
{
  268435464,
  270532608,
  8192,
  270540808,
  270532608,
  8,
  270540808,
  2097152,
  268443648,
  2105352,
  2097152,
  268435464,
  2097160,
  268443648,
  268435456,
  8200,
  0,
  2097160,
  268443656,
  8192,
  2105344,
  268443656,
  8,
  270532616,
  270532616,
  0,
  2105352,
  270540800,
  8200,
  2105344,
  270540800,
  268435456
}; // weak
_UNKNOWN unk_E66D; // weak
int dword_E6EC[64] =
{
  1048576,
  34603009,
  33555457,
  0,
  1024,
  33555457,
  1049601,
  34604032,
  34604033,
  1048576,
  0,
  33554433,
  1,
  33554432,
  34603009,
  1025,
  33555456,
  1049601,
  1048577,
  33555456,
  33554433,
  34603008,
  34604032,
  1048577,
  34603008,
  1024,
  1025,
  34604033,
  1049600,
  1,
  33554432,
  1049600,
  33554432,
  1049600,
  1048576,
  33555457,
  33555457,
  34603009,
  34603009,
  1,
  1048577,
  33554432,
  33555456,
  1048576,
  34604032,
  1025,
  1049601,
  34604032,
  1025,
  33554433,
  34604033,
  34603008,
  1049600,
  0,
  1,
  34604033,
  0,
  1049601,
  34603008,
  1024,
  33554433,
  33555456,
  1024,
  1048577
}; // weak
int dword_E7EC[65] =
{
  134219808,
  2048,
  131072,
  134350880,
  134217728,
  134219808,
  32,
  134217728,
  131104,
  134348800,
  134350880,
  133120,
  134350848,
  133152,
  2048,
  32,
  134348800,
  134217760,
  134219776,
  2080,
  133120,
  131104,
  134348832,
  134350848,
  2080,
  0,
  0,
  134348832,
  134217760,
  134219776,
  133152,
  131072,
  133152,
  131072,
  134350848,
  2048,
  32,
  134348832,
  2048,
  133152,
  134219776,
  32,
  134217760,
  134348800,
  134348832,
  134217728,
  131072,
  134219808,
  0,
  134350880,
  131104,
  134217760,
  134348800,
  134219776,
  134219808,
  0,
  134350880,
  133120,
  133120,
  2080,
  2080,
  131104,
  134217728,
  134350848,
  59636
}; // weak
int dword_E8F0 = 0; // weak
_UNKNOWN *off_E8F8 = (_UNKNOWN *)0x330E; // weak
_UNKNOWN *off_E8FC = (_UNKNOWN *)0xABCD; // weak
int dword_E900 = 4660; // weak
_UNKNOWN *off_E904 = &unk_E66D; // weak
int (*off_E908)[69] = &dword_DEEC; // weak
int dword_E90C = 5; // weak
int dword_E910 = 11; // weak
double dbl_E914 = 0.0000152587890625; // weak
int dword_E920 = 0; // weak
int dword_E924 = 0; // weak
_UNKNOWN *off_EAB0 = &unk_E928; // weak
int (__cdecl *off_EAC0)(int a1) = &sub_5524; // weak
__int16 *off_EAC8 = &word_2A86; // weak
int (*off_EAD0)[67] = &dword_2D88; // weak
_DWORD dword_EB78[20] = { -72540026, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60200, 60488, 2, 0, 0, 0, 0 }; // weak
_UNKNOWN *off_EBC8 = &dword_EB78; // weak
int dword_EBD0 = 0; // weak
int dword_EBD4 = 0; // weak
int dword_EBD8 = 1; // weak
int dword_EBDC = 63; // weak
int dword_EBE0 = 0; // weak
int dword_EBE8 = 0; // weak
int dword_EBF0 = 0; // weak
int dword_EBF8 = 0; // weak
_UNKNOWN unk_EC00; // weak
char *off_EC40 = "C"; // weak
double dbl_ECE0[5] = { ?flt, ?flt, ?flt, ?flt, ?flt }; // weak
int dword_ED0C[5] = { 0, 5, 25, 125, 625 }; // weak
double dbl_ED20[] = { ?flt }; // weak
double dbl_ED28[23] =
{
  1.0,
  10.0,
  100.0,
  1000.0,
  10000.0,
  100000.0,
  1000000.0,
  1.0e7,
  1.0e8,
  1.0e9,
  1.0e10,
  1.0e11,
  1.0e12,
  1.0e13,
  1.0e14,
  1.0e15,
  1.0e16,
  1.0e17,
  1.0e18,
  1.0e19,
  1.0e20,
  1.0e21,
  1.0e22
}; // weak
double dbl_EDE0[4] = { 1.0e16, 1.0e32, 1.0e64, 1.0e128 }; // weak
double dbl_EE00 = 1.0e256; // weak
double dbl_EE08[5] = { 1.0e-16, 1.0e-32, 1.0e-64, 1.0e-128, 1.0e-256 }; // weak
int dword_EE30 = 0; // weak
__int16 word_EE38[24] =
{
  10,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  -28528,
  0,
  0,
  1,
  0,
  -8196,
  0
}; // weak
int dword_EE68 = 0; // weak
int dword_EE94 = 0; // weak
int dword_EE98 = 0; // weak
int dword_EE9C = 0; // weak
int dword_EEA0 = 0; // weak
int dword_EEA4 = 0; // weak
int dword_EEA8 = 0; // weak
int dword_EEAC = 0; // weak
int dword_EEC4 = 0; // weak
int dword_EEC8 = 0; // weak
int dword_EECC = 0; // weak
int dword_EED0 = 0; // weak
int dword_EED4 = 0; // weak
_DWORD dword_EED8[24] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_EF38 = 0; // weak
_BYTE algn_EF3C[196] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_F748; // weak
int dword_F750; // weak
int dword_F808[12]; // weak


//----- (00000000) --------------------------------------------------------
#error "0: call analysis failed (funcsize=15)"

//----- (00000134) --------------------------------------------------------
int __cdecl sub_134(int a1)
{
  int v1; // ecx
  int v2; // ebx
  int v3; // edx

  v1 = 57372;
  v2 = 16;
  do
  {
    v3 = 0;
    while ( ((*(_BYTE *)(v3 + a1) ^ *(_BYTE *)(v3 + v1)) & 0xFE) == 0 )
    {
      if ( (unsigned int)++v3 > 7 )
        return v2;
    }
    v1 += 8;
    --v2;
  }
  while ( v2 );
  return v2;
}

//----- (00000184) --------------------------------------------------------
int __cdecl sub_184(char a1)
{
  if ( (unsigned __int8)(a1 - 48) <= 9u )
    return a1 - 48;
  if ( (unsigned __int8)(a1 - 97) <= 5u )
    return a1 - 87;
  if ( (unsigned __int8)(a1 - 65) <= 5u )
    return a1 - 55;
  return -1;
}

//----- (00000274) --------------------------------------------------------
int __cdecl sub_274(_BYTE **a1, unsigned __int8 *a2, char *a3, int a4)
{
  int v4; // ebx

  if ( a3 )
  {
    sub_D38(a2, a3, 0x20u);
    sub_20AC((int)a3, 0, strlen(a3));
  }
  v4 = sub_134((int)a2);
  sub_FA0(a1, (int)a2, 8u, a4);
  sub_20AC((int)a2, 0, 8u);
  if ( !*a1 )
  {
    sub_7564("Memory allocation error\n", dword_EB78);
    sub_3A14(1);
  }
  return v4;
}
// EB78: using guessed type _DWORD dword_EB78[20];

//----- (00000304) --------------------------------------------------------
_BOOL4 __cdecl sub_304(char *a1, const char *a2, const char *a3, int a4)
{
  char *v4; // ebx
  char *v5; // edi
  char *i; // esi
  int v7; // edx
  char v8; // al
  char *v9; // esi

  v4 = a1;
  v5 = (char *)a2;
  for ( i = (char *)a3; *v4; *v5++ = v8 )
  {
    v7 = *v4;
    if ( (off_EAC8[v7] & 3) == 0 )
      break;
    ++v4;
    v8 = (unsigned __int8)v7 == v7 ? *((_BYTE *)off_EAD0 + (unsigned __int8)v7) : v7;
  }
  *v5 = 0;
  if ( strlen(a2) <= 2 )
    return 0;
  while ( *v4 && (off_EAC8[*v4] & 8) != 0 )
    *i++ = *v4++;
  *i = 0;
  if ( strlen(a3) <= 6 )
    return 0;
  v9 = i - 6;
  sub_2000(a4, v9);
  *v9 = 0;
  return *v4 == 0;
}
// EAC8: using guessed type __int16 *off_EAC8;
// EAD0: using guessed type int (*off_EAD0)[67];

//----- (000003F4) --------------------------------------------------------
char __cdecl sub_3F4(const char *a1)
{
  char *v1; // ebx
  unsigned int v2; // eax
  char *v3; // edx

  v1 = (char *)a1;
  v2 = strlen(a1) + 1;
  v3 = (char *)&a1[v2 - 2];
  if ( v3 > a1 )
  {
    do
    {
      LOBYTE(v2) = *v1;
      *v1 = *v3;
      *v3 = v2;
      ++v1;
      --v3;
    }
    while ( v3 > v1 );
  }
  return v2;
}

//----- (00000444) --------------------------------------------------------
int __cdecl sub_444(int a1)
{
  int v1; // ebx
  unsigned __int8 *v2; // esi
  char *v3; // edi
  int v4; // ecx
  bool v5; // zf
  int v6; // eax

  v1 = a1;
  v2 = sub_2E94("LANG");
  v3 = "german";
  v4 = 7;
  v6 = 0;
  v5 = 1;
  do
  {
    if ( !v4 )
      break;
    v5 = *v2++ == (unsigned __int8)*v3++;
    --v4;
  }
  while ( v5 );
  if ( !v5 )
    v6 = *(v2 - 1) - (unsigned __int8)*(v3 - 1);
  if ( v6 )
    v1 = a1 + 3;
  sub_7564((const char *)dword_E000[v1], dword_EB78);
  return sub_7564((const char *)sub_437, dword_EB78);
}
// 437: using guessed type int sub_437();
// E000: using guessed type int dword_E000[3];
// EB78: using guessed type _DWORD dword_EB78[20];

//----- (000004C4) --------------------------------------------------------
int __cdecl sub_4C4(_BYTE *a1)
{
  _BYTE *v1; // ecx
  int v2; // edi
  int v3; // edx
  int v4; // eax
  int i; // [esp+Ch] [ebp-4h] BYREF

  v1 = a1;
  v2 = 0;
  for ( i = 1094864213; *v1; ++v1 )
  {
    v3 = v2++;
    v4 = v3 + (v3 < 0 ? 3 : 0);
    LOBYTE(v4) = v4 & 0xFC;
    *((_BYTE *)&i + v3 - v4) ^= *v1;
  }
  return i;
}

//----- (00000564) --------------------------------------------------------
int __cdecl sub_564(int a1, int *a2)
{
  char *v2; // esi
  char v3; // al
  int v5; // esi
  int v6; // ebx
  unsigned int v7; // kr04_4
  int v8; // esi
  int v9; // ebx
  char *v10; // eax
  unsigned int v11; // eax
  unsigned int i; // ebx
  unsigned int v13; // ebx
  int v14; // eax
  unsigned int j; // ebx
  int v16; // eax
  int v17; // esi
  int v18; // ebx
  signed int v19; // edi
  int v20; // esi
  int v21; // ebx
  char *v22; // eax
  int v23; // [esp-Ch] [ebp-3C4h]
  int v24; // [esp-Ch] [ebp-3C4h]
  char *addr; // [esp+Ch] [ebp-3ACh]
  int v26; // [esp+10h] [ebp-3A8h]
  int v27; // [esp+14h] [ebp-3A4h]
  int v28; // [esp+18h] [ebp-3A0h]
  int v29; // [esp+20h] [ebp-398h]
  int v30; // [esp+24h] [ebp-394h]
  int v31; // [esp+28h] [ebp-390h] BYREF
  unsigned int v32; // [esp+2Ch] [ebp-38Ch] BYREF
  unsigned __int8 v33[8]; // [esp+30h] [ebp-388h] BYREF
  _BYTE v34[128]; // [esp+38h] [ebp-380h] BYREF
  unsigned __int8 v35[128]; // [esp+B8h] [ebp-300h] BYREF
  char v36[128]; // [esp+138h] [ebp-280h] BYREF
  char v37[128]; // [esp+1B8h] [ebp-200h] BYREF
  char v38[128]; // [esp+238h] [ebp-180h] BYREF
  char v39[256]; // [esp+2B8h] [ebp-100h] BYREF
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  sub_1ACC();
  v2 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 1;
  v26 = 62272;
  addr = algn_EF3C + 4;
  if ( a1 != 3 )
  {
    sub_444(3);
    sub_3A14(1);
  }
  dword_F750 = 1;
  while ( 1 )
  {
    v3 = sub_39F4(&savedregs, 3, a2, (char *)&unk_510);
    if ( v3 == -1 )
      break;
    if ( v3 != 107 )
    {
      sub_444(3);
      return 1;
    }
    v2 = (char *)dword_EBD0;
  }
  if ( !sub_304(v2, v38, v37, (int)v36) )
  {
    sub_444(1);
    sub_3A14(1);
  }
  if ( !memcmp(v38, &byte_511[2], 6u) && !memcmp(v38, "MMDEV", 6u) && !memcmp(v38, "MMDOC", 6u) )
  {
    sub_2000((int)v34, v38);
    sub_274((_BYTE **)&unk_F748, v33, v38, 0);
    v28 = 1;
    v5 = 63296;
    v6 = 0;
    do
    {
      *(_DWORD *)(v6 + 63308) = 8;
      v23 = v5;
      v5 += 20;
      v6 += 20;
      ++v29;
      sub_20AC(v23, 0, 8u);
    }
    while ( v29 < 1 );
    v7 = strlen(off_E00C[0]) + 1;
    if ( (int)(v7 - 1) > 0 )
    {
      sub_2000(61248, off_E00C[0]);
      v8 = 1;
      v9 = 63296;
      do
      {
        v10 = addr;
        addr = (char *)v26;
        v26 = (int)v10;
        *(_DWORD *)(v9 + 12) = sub_18D0(
                                 addr,
                                 v10,
                                 v7 - 1,
                                 (unsigned __int8 *)v9,
                                 *(_DWORD *)(v9 + 12),
                                 *(_DWORD *)(v9 + 8),
                                 *(_DWORD *)(v9 + 16));
        v9 += 20;
        --v8;
      }
      while ( v8 );
      v28 = 0;
      v27 = 1;
    }
    v11 = sub_4C4(addr);
    sub_1D1C(v11);
    sub_75F4(v36, "%lu", &v32);
    for ( i = 0; i < v32 % 0x47F; ++i )
      sub_1B9C();
    v13 = sub_1B9C();
    sub_75F4(v37, "%lu", &v31);
    v14 = v31 ^ v13;
  }
  else
  {
    sub_3F4(v37);
    sub_75F4(v37, "%lu", &v31);
    sub_75F4(v36, "%lu", &v32);
    sub_1D1C(0x41424D55u);
    for ( j = 0; j < v32 % 0x47F; ++j )
      sub_1B9C();
    v14 = v31 + sub_1B9C();
  }
  sub_75DC((const char *)v35, 1321, v14);
  if ( sub_211C(v35, "222", 3) )
  {
    sub_444(1);
    sub_3A14(1);
  }
  sub_2000((int)v39, v38);
  sub_20F8(v39, (char *)v35);
  sub_274((_BYTE **)&unk_F748, v33, v39, 0);
  if ( !v28 )
    v28 = 1;
  if ( v29 > 1 )
    v27 = v29;
  if ( v28 < v27 )
  {
    v16 = 20 * v28;
    do
    {
      *(_DWORD *)(v16 + 63312) = dword_F750;
      v16 += 20;
      ++v28;
    }
    while ( v28 < v27 );
  }
  if ( v29 < v27 )
  {
    v17 = 20 * v29 + 63296;
    v18 = 20 * v29;
    do
    {
      *(_DWORD *)(v18 + 63308) = 8;
      v24 = v17;
      v17 += 20;
      v18 += 20;
      ++v29;
      sub_20AC(v24, 0, 8u);
    }
    while ( v29 < v27 );
  }
  do
  {
    v19 = sub_562C(0, addr, 0x400u);
    if ( v19 <= 0 )
      break;
    v20 = v27;
    v21 = 63296;
    do
    {
      v22 = addr;
      addr = (char *)v26;
      v26 = (int)v22;
      *(_DWORD *)(v21 + 12) = sub_18D0(
                                addr,
                                v22,
                                v19,
                                (unsigned __int8 *)v21,
                                *(_DWORD *)(v21 + 12),
                                *(_DWORD *)(v21 + 8),
                                *(_DWORD *)(v21 + 16));
      v21 += 20;
      --v20;
    }
    while ( v20 );
    v30 = sub_5678(1, addr, v19);
  }
  while ( v30 == v19 );
  if ( v19 >= 0 )
  {
    if ( !v19 || v30 == v19 )
    {
      return 0;
    }
    else
    {
      sub_7514(dword_EB78, 1349, off_4810[dword_E924]);
      return 2;
    }
  }
  else
  {
    sub_7514(dword_EB78, 1332, off_4810[dword_E924]);
    return 3;
  }
}
// 6D4: conditional instruction was optimized away because %var_3A0.4==0
// 6EC: conditional instruction was optimized away because %var_3A0.4==1
// 706: conditional instruction was optimized away because %var_398.4==0
// 720: conditional instruction was optimized away because %var_39C.4==0
// 73A: conditional instruction was optimized away because %var_3A0.4==1
// 77D: conditional instruction was optimized away because %var_398.4==0
// 9F7: conditional instruction was optimized away because %var_3A0.4==1
// A2B: conditional instruction was optimized away because %var_3A4.4>=1
// 4810: using guessed type char *off_4810[122];
// E00C: using guessed type char *off_E00C[3];
// E924: using guessed type int dword_E924;
// EB78: using guessed type _DWORD dword_EB78[20];
// EBD0: using guessed type int dword_EBD0;
// EF3C: using guessed type _BYTE algn_EF3C[196];
// F750: using guessed type int dword_F750;

//----- (00000BC4) --------------------------------------------------------
int __cdecl sub_BC4(int d, int a2)
{
  char v3; // [esp+12h] [ebp-Eh]

  sub_55B8(d, 21509);
  if ( a2 >= 0 )
    sub_55B8(d, 21510);
  return v3 & 8;
}
// BE6: variable 'v3' is possibly undefined

//----- (00000C68) --------------------------------------------------------
_BYTE *__cdecl sub_C68(unsigned __int8 *a1, char *a2, unsigned int a3, unsigned __int8 a4, int a5)
{
  unsigned int v6; // esi
  unsigned __int8 v8; // [esp+Ch] [ebp-Ch]
  _BYTE v9[8]; // [esp+10h] [ebp-8h] BYREF

  v6 = a3;
  v8 = a4;
  sub_20AC((int)a1, 0, 8u);
  if ( a3 > 8 )
  {
    do
    {
      sub_18A0(a1, a1, a2, 8);
      sub_1830(a1, a1, a5);
      a2 += 8;
      v6 -= 8;
    }
    while ( v6 > 8 );
  }
  sub_1FC4((int)v9, a2, v6);
  sub_20AC((int)&v9[v6], v8, 8 - v6);
  sub_18A0(a1, a1, v9, 8);
  return sub_1830(a1, a1, a5);
}

//----- (00000D08) --------------------------------------------------------
int __cdecl sub_D08(_BYTE *a1, _BYTE *a2, int a3)
{
  int result; // eax

  for ( result = a3; result; --result )
    *a1++ = 2 * *a2++;
  return result;
}

//----- (00000D38) --------------------------------------------------------
void __cdecl sub_D38(unsigned __int8 *a1, char *a2, unsigned __int8 a3)
{
  unsigned int v3; // kr04_4
  int v4; // edi
  _BYTE *v5; // [esp+Ch] [ebp-4h] BYREF

  v3 = strlen(a2) + 1;
  v4 = v3 - 1;
  v5 = 0;
  if ( v3 - 1 > 8 )
    v4 = 8;
  sub_D08(a1, a2, v4);
  sub_20AC((int)&a1[v4], 2 * a3, 8 - v4);
  sub_FA0(&v5, (int)a1, 8u, 0);
  sub_C68(a1, &a2[v4], v3 - 1 - v4, a3, (int)v5);
  sub_26E8(v5);
}

//----- (00000DD0) --------------------------------------------------------
int __cdecl sub_DD0(char *a1, unsigned __int8 a2)
{
  char v2; // bl
  int result; // eax

  v2 = *a1;
  result = sub_1FC4((int)a1, a1 + 1, a2 - 1);
  a1[a2 - 1] = v2;
  return result;
}

//----- (00000E00) --------------------------------------------------------
char __cdecl sub_E00(int a1, char *a2, unsigned __int8 a3, unsigned __int8 a4, unsigned int a5)
{
  _BYTE *v5; // esi
  unsigned int v6; // ebx
  char result; // al
  _BYTE v9[67]; // [esp+Dh] [ebp-43h] BYREF

  v5 = (_BYTE *)(a3 + a1);
  v6 = a3 + a5;
  sub_1FC4((int)v9, a2, a4);
  do
  {
    --v5;
    result = v9[*(unsigned __int8 *)--v6 - 1];
    *v5 = result;
  }
  while ( v6 > a5 );
  return result;
}

//----- (00000E50) --------------------------------------------------------
_BYTE *__cdecl sub_E50(_BYTE *a1, _BYTE *a2)
{
  *a1 = a2[4] | (2 * (*a2 | (2 * (a2[23] | (2 * (a2[10] | (2 * (a2[16] | (2 * a2[13])))))))));
  a1[1] = a2[9] | (2 * (a2[20] | (2 * (a2[5] | (2 * (a2[14] | (2 * (a2[27] | (2 * a2[2])))))))));
  a1[2] = a2[7] | (2 * (a2[25] | (2 * (a2[3] | (2 * (a2[11] | (2 * (a2[18] | (2 * a2[22])))))))));
  a1[3] = a2[1] | (2 * (a2[12] | (2 * (a2[19] | (2 * (a2[26] | (2 * (a2[6] | (2 * a2[15])))))))));
  a1[4] = a2[54] | (2 * (a2[46] | (2 * (a2[36] | (2 * (a2[30] | (2 * (a2[51] | (2 * a2[40])))))))));
  a1[5] = a2[47] | (2 * (a2[32] | (2 * (a2[44] | (2 * (a2[50] | (2 * (a2[39] | (2 * a2[29])))))))));
  a1[6] = a2[52] | (2 * (a2[33] | (2 * (a2[55] | (2 * (a2[38] | (2 * (a2[48] | (2 * a2[43])))))))));
  a1[7] = a2[31] | (2 * (a2[28] | (2 * (a2[35] | (2 * (a2[49] | (2 * (a2[41] | (2 * a2[45])))))))));
  return a2;
}

//----- (00000F60) --------------------------------------------------------
int __cdecl sub_F60(int a1, unsigned __int8 *a2)
{
  int v3; // edi
  int v4; // eax
  unsigned __int8 v5; // cl
  int v6; // edx

  v3 = 8;
  v4 = a1 - 8;
  do
  {
    v4 += 16;
    v5 = *a2++;
    v6 = 8;
    do
    {
      *(_BYTE *)--v4 = v5 & 1;
      v5 >>= 1;
      --v6;
    }
    while ( v6 );
    --v3;
  }
  while ( v3 );
  return v4 + 8;
}

//----- (00000FA0) --------------------------------------------------------
_BYTE *__cdecl sub_FA0(_BYTE **a1, int a2, unsigned int a3, int a4)
{
  _BYTE *result; // eax
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int v8; // [esp+Ch] [ebp-84h]
  int v9; // [esp+Ch] [ebp-84h]
  _DWORD v10[2]; // [esp+10h] [ebp-80h] BYREF
  char v11[28]; // [esp+18h] [ebp-78h] BYREF
  char v12[28]; // [esp+34h] [ebp-5Ch] BYREF
  char v13[64]; // [esp+50h] [ebp-40h] BYREF

  if ( *a1 || (result = (_BYTE *)sub_2378(0x81u), (*a1 = result) != 0) )
  {
    **a1 = a4;
    if ( a3 <= 7 )
    {
      sub_1FC4((int)v10, (char *)a2, a3);
      sub_20AC((int)v10 + a3, 0, 8 - a3);
    }
    else
    {
      v10[0] = *(_DWORD *)a2;
      v10[1] = *(_DWORD *)(a2 + 4);
    }
    sub_F60((int)v13, (unsigned __int8 *)v10);
    sub_E00((int)v11, v13, 0x38u, 0x40u, 0xE0B4u);
    LOBYTE(v5) = 0;
    do
    {
      v6 = 0;
      if ( byte_E0A4[(unsigned __int8)v5] )
      {
        do
        {
          v8 = v5;
          sub_DD0(v11, 0x1Cu);
          sub_DD0(v12, 0x1Cu);
          ++v6;
          v5 = v8;
        }
        while ( v6 < byte_E0A4[(unsigned __int8)v8] );
      }
      if ( a4 )
        v7 = (unsigned __int8)v5;
      else
        v7 = 15 - (unsigned __int8)v5;
      v9 = v5;
      result = sub_E50(&(*a1)[8 * v7 + 1], v11);
      v5 = v9;
      LOBYTE(v5) = v9 + 1;
    }
    while ( (unsigned __int8)(v9 + 1) <= 0xFu );
  }
  return result;
}
// 104F: variable 'v5' is possibly undefined
// E0A4: using guessed type unsigned __int8[72];

//----- (00001100) --------------------------------------------------------
_BYTE *__cdecl sub_1100(_BYTE *a1, unsigned int *a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // ecx

  v3 = a2[1];
  a1[7] = v3;
  v3 >>= 8;
  a1[6] = v3;
  v3 >>= 8;
  a1[5] = v3;
  a1[4] = BYTE1(v3);
  v4 = *a2;
  a1[3] = *a2;
  v4 >>= 8;
  a1[2] = v4;
  v4 >>= 8;
  a1[1] = v4;
  *a1 = BYTE1(v4);
  return a1;
}

//----- (00001140) --------------------------------------------------------
int __cdecl sub_1140(int *a1, unsigned __int8 *a2)
{
  int result; // eax

  *a1 = a2[3] | ((a2[2] | ((a2[1] | (*a2 << 8)) << 8)) << 8);
  result = a2[7];
  a1[1] = result | ((a2[6] | ((a2[5] | (a2[4] << 8)) << 8)) << 8);
  return result;
}

//----- (000011A0) --------------------------------------------------------
int __cdecl sub_11A0(unsigned int *a1, _DWORD *a2)
{
  unsigned int v2; // esi
  unsigned int v3; // edx
  int result; // eax

  v2 = a2[1];
  v3 = (v2 >> 15) & 0x1000
     | (v2 >> 12) & 0x20
     | (v2 >> 9) & 0x100000
     | (v2 >> 6) & 0x2000
     | (v2 >> 3) & 0x10000040
     | (v2 << 24) & 0x80000000
     | (v2 << 18) & 0x800000
     | (v2 << 15) & 0x40000000
     | ((_WORD)v2 << 12) & 0x8000
     | (v2 << 9) & 0x400000
     | (v2 << 6) & 0x20000080
     | (8 * (_WORD)v2) & 0x4000
     | v2 & 0x200000
     | (*a2 >> 25) & 1
     | (*a2 >> 19) & 0x100
     | HIWORD(*a2) & 2
     | (*a2 >> 13) & 0x10000
     | (*a2 >> 10) & 0x200
     | (*a2 >> 7) & 0x1000004
     | (*a2 >> 4) & 0x20000
     | (*a2 >> 1) & 0x400
     | (*a2 << 20) & 0x8000000
     | (*a2 << 14) & 0x80000
     | (*a2 << 11) & 0x4000000
     | ((unsigned __int16)*a2 << 8) & 0x800
     | (32 * *a2) & 0x40000
     | (4 * *a2) & 0x2000008;
  result = (v2 >> 21) & 0x10;
  *a1 = (v2 >> 20) & 0x10
      | (v2 >> 14) & 0x1000
      | (v2 >> 11) & 0x20
      | (v2 >> 8) & 0x100000
      | (v2 >> 5) & 0x2000
      | (v2 >> 2) & 0x10000040
      | (v2 << 25) & 0x80000000
      | (v2 << 19) & 0x800000
      | (v2 << 16) & 0x40000000
      | ((_WORD)v2 << 13) & 0x8000
      | (v2 << 10) & 0x400000
      | (v2 << 7) & 0x20000080
      | (16 * (_WORD)v2) & 0x4000
      | (2 * v2) & 0x200000
      | HIBYTE(*a2) & 1
      | (*a2 >> 18) & 0x100
      | (*a2 >> 15) & 2
      | (*a2 >> 12) & 0x10000
      | (*a2 >> 9) & 0x200
      | (*a2 >> 6) & 0x1000004
      | (*a2 >> 3) & 0x20000
      | (*a2 << 21) & 0x8000000
      | (*a2 << 15) & 0x80000
      | (*a2 << 12) & 0x4000000
      | ((unsigned __int16)*a2 << 9) & 0x800
      | (*a2 << 6) & 0x40000
      | (8 * *a2) & 0x2000008
      | *a2 & 0x400;
  a1[1] = result | v3;
  return result;
}

//----- (00001450) --------------------------------------------------------
int __cdecl sub_1450(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  int result; // eax

  *a1 = ((a3 & 8) != 0)
      | (a2 >> 2) & 2
      | (a3 >> 9) & 4
      | (a2 >> 8) & 8
      | (a3 >> 15) & 0x10
      | (a2 >> 14) & 0x20
      | (a3 >> 21) & 0x40
      | (a2 >> 20) & 0x80
      | ((_WORD)a3 << 6) & 0x100
      | ((_WORD)a2 << 7) & 0x200
      | a3 & 0x400
      | (2 * (_WORD)a2) & 0x800
      | (a3 >> 6) & 0x1000
      | (a2 >> 5) & 0x2000
      | (a3 >> 12) & 0x4000
      | (a2 >> 11) & 0x8000
      | (a3 << 15) & 0x10000
      | (a2 << 16) & 0x20000
      | (a3 << 9) & 0x40000
      | (a2 << 10) & 0x80000
      | (8 * a3) & 0x100000
      | (16 * a2) & 0x200000
      | (a3 >> 3) & 0x400000
      | (a2 >> 2) & 0x800000
      | (a3 << 24) & 0x1000000
      | (a2 << 25) & 0x2000000
      | (a3 << 18) & 0x4000000
      | (a2 << 19) & 0x8000000
      | (a3 << 12) & 0x10000000
      | (a2 << 13) & 0x20000000
      | (a3 << 6) & 0x40000000
      | (a2 << 7) & 0x80000000;
  result = (a3 >> 19) & 0x10;
  a1[1] = ((a3 & 0x80) != 0)
        | (a2 >> 6) & 2
        | (a3 >> 13) & 4
        | (a2 >> 12) & 8
        | result
        | (a2 >> 18) & 0x20
        | (a3 >> 25) & 0x40
        | HIBYTE(a2) & 0x80
        | (4 * (_WORD)a3) & 0x100
        | (8 * (_WORD)a2) & 0x200
        | (a3 >> 4) & 0x400
        | (a2 >> 3) & 0x800
        | (a3 >> 10) & 0x1000
        | (a2 >> 9) & 0x2000
        | HIWORD(a3) & 0x4000
        | (a2 >> 15) & 0x8000
        | (a3 << 11) & 0x10000
        | (a2 << 12) & 0x20000
        | (32 * a3) & 0x40000
        | (a2 << 6) & 0x80000
        | (a3 >> 1) & 0x100000
        | a2 & 0x200000
        | (a3 >> 7) & 0x400000
        | (a2 >> 6) & 0x800000
        | (a3 << 20) & 0x1000000
        | (a2 << 21) & 0x2000000
        | (a3 << 14) & 0x4000000
        | (a2 << 15) & 0x8000000
        | (a3 << 8) & 0x10000000
        | (a2 << 9) & 0x20000000
        | (4 * a3) & 0x40000000
        | (8 * a2) & 0x80000000;
  return result;
}

//----- (00001760) --------------------------------------------------------
unsigned int __cdecl sub_1760(unsigned int a1, unsigned __int8 *a2)
{
  return dword_E1EC[((16 * ((a1 >> 27) & 3)) | (((32 * a1) | (a1 >> 27)) >> 28)) ^ a2[1]]
       | (unsigned int)*(&off_E2EC + ((((32 * a1) | (a1 >> 27)) >> 24) & 0x3F ^ a2[2]))
       | dword_E3EC[(((32 * a1) | (a1 >> 27)) >> 20) & 0x3F ^ a2[3]]
       | (unsigned int)(&off_E4EC)[(((32 * a1) | (a1 >> 27)) >> 16) & 0x3F ^ a2[4]]
       | dword_E5EC[(((32 * a1) | (a1 >> 27)) >> 12) & 0x3F ^ a2[5]]
       | dword_E6EC[((unsigned __int16)((32 * a1) | (a1 >> 27)) >> 8) & 0x3F ^ a2[6]]
       | dword_E7EC[(((32 * a1) | (a1 >> 27)) >> 4) & 0x3F ^ a2[7]]
       | dword_E0EC[((unsigned __int8)(32 * a1) | (a1 >> 27)) & 0x3F ^ *a2];
}
// E0EC: using guessed type int dword_E0EC[64];
// E1EC: using guessed type int dword_E1EC[64];
// E2EC: using guessed type _UNKNOWN *off_E2EC;
// E3EC: using guessed type int dword_E3EC[64];
// E4EC: using guessed type char *off_E4EC;
// E5EC: using guessed type int dword_E5EC[32];
// E6EC: using guessed type int dword_E6EC[64];
// E7EC: using guessed type int dword_E7EC[65];

//----- (00001830) --------------------------------------------------------
_BYTE *__cdecl sub_1830(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // ebx
  unsigned int v5; // eax
  char v7; // [esp+Ch] [ebp-1Ch]
  unsigned int v8[2]; // [esp+10h] [ebp-18h] BYREF
  unsigned int v9[2]; // [esp+18h] [ebp-10h] BYREF
  int v10[2]; // [esp+20h] [ebp-8h] BYREF

  v7 = 16;
  sub_1140(v10, a2);
  sub_11A0(v9, v10);
  v3 = v9[0];
  v4 = v9[1];
  do
  {
    v5 = v3 ^ sub_1760(v4, (unsigned __int8 *)(a3 + 8 * (unsigned __int8)--v7 + 1));
    v3 = v4;
    v4 = v5;
  }
  while ( v7 );
  sub_1450(v8, v3, v5);
  return sub_1100(a1, v8);
}

//----- (000018A0) --------------------------------------------------------
int __cdecl sub_18A0(_BYTE *a1, _BYTE *a2, _BYTE *a3, int a4)
{
  int result; // eax

  for ( result = a4; result; --result )
    *a1++ = *a3++ ^ *a2++;
  return result;
}

//----- (000018D0) --------------------------------------------------------
unsigned int __cdecl sub_18D0(
        char *a1,
        _BYTE *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int a5,
        int a6,
        int a7)
{
  _BYTE *v7; // edi
  unsigned int v8; // esi
  char *v10; // [esp+Ch] [ebp-4h]

  v7 = a2;
  v8 = a3;
  v10 = a1;
  if ( a7 )
    v10 = a2;
  if ( a5 != 8 )
  {
    if ( a3 < a5 )
    {
      sub_18A0(a1, a4, a2, a3);
      sub_1FC4((int)a4, (char *)&a4[a3], 8 - a3);
      sub_1FC4((int)&a4[-a3 + 8], v10, a3);
      return a5 - a3;
    }
    sub_18A0(a1, a4, a2, a5);
    sub_1FC4((int)a4, (char *)&a4[a5], 8 - a5);
    sub_1FC4((int)&a4[-a5 + 8], v10, a5);
    a1 += a5;
    v7 = &a2[a5];
    v10 += a5;
    v8 = a3 - a5;
  }
  if ( v8 )
    sub_1830(a4, a4, a6);
  while ( v8 > 8 )
  {
    sub_18A0(a1, a4, v7, 8);
    sub_1830(a4, (unsigned __int8 *)v10, a6);
    a1 += 8;
    v7 += 8;
    v10 += 8;
    v8 -= 8;
  }
  sub_18A0(a1, a4, v7, v8);
  sub_1FC4((int)a4, (char *)&a4[v8], 8 - v8);
  sub_1FC4((int)&a4[8 - v8], v10, v8);
  return 8 - v8;
}

//----- (00001A8C) --------------------------------------------------------
int sub_1A8C()
{
  void (**v0)(void); // ebx
  void (*v1)(void); // eax

  v0 = (void (**)(void))&dword_EEC4;
  if ( dword_EEC4 )
  {
    do
    {
      v1 = *v0++;
      v1();
    }
    while ( *v0 );
  }
  return sub_1EFC(6716);
}
// EEC4: using guessed type int dword_EEC4;

//----- (00001ACC) --------------------------------------------------------
int sub_1ACC()
{
  int result; // eax

  if ( !dword_E8F0 )
  {
    dword_E8F0 = 1;
    return sub_1A8C();
  }
  return result;
}
// E8F0: using guessed type int dword_E8F0;

//----- (00001AEC) --------------------------------------------------------
long double sub_1AEC()
{
  sub_1BDC();
  return (((long double)(unsigned int)off_E8F8 * dbl_E914 + (long double)(unsigned int)off_E8FC) * dbl_E914
        + (long double)(unsigned int)dword_E900)
       * dbl_E914;
}
// E8F8: using guessed type _UNKNOWN *off_E8F8;
// E8FC: using guessed type _UNKNOWN *off_E8FC;
// E900: using guessed type int dword_E900;
// E914: using guessed type double dbl_E914;

//----- (00001B3C) --------------------------------------------------------
int __cdecl sub_1B3C(unsigned __int16 *a1)
{
  int v1; // eax
  _DWORD *v2; // edx
  unsigned __int16 *v3; // ecx
  int result; // eax
  unsigned __int16 *v5; // edx
  unsigned __int16 *v6; // ecx
  _DWORD v7[3]; // [esp+8h] [ebp-Ch]

  v1 = 0;
  v2 = &off_E8F8;
  v3 = a1;
  do
  {
    v7[v1] = *v2;
    *v2++ = *v3++;
    ++v1;
  }
  while ( v1 <= 2 );
  sub_1AEC();
  result = 0;
  v5 = (unsigned __int16 *)&off_E8F8;
  v6 = a1;
  do
  {
    *v6 = *v5;
    *(_DWORD *)v5 = v7[result];
    v5 += 2;
    ++v6;
    ++result;
  }
  while ( result <= 2 );
  return result;
}
// E8F8: using guessed type _UNKNOWN *off_E8F8;

//----- (00001B9C) --------------------------------------------------------
unsigned int sub_1B9C()
{
  sub_1BDC();
  return ((unsigned int)off_E8FC >> 1) + (dword_E900 << 15);
}
// E8FC: using guessed type _UNKNOWN *off_E8FC;
// E900: using guessed type int dword_E900;

//----- (00001BBC) --------------------------------------------------------
int sub_1BBC()
{
  int result; // eax

  sub_1BDC();
  result = (int)off_E8FC + 0x10000 * dword_E900;
  if ( result < 0 )
    return result | 0x80000000;
  return result;
}
// E8FC: using guessed type _UNKNOWN *off_E8FC;
// E900: using guessed type int dword_E900;

//----- (00001BDC) --------------------------------------------------------
void *sub_1BDC()
{
  unsigned int v0; // esi
  _BOOL2 v1; // bp
  int v2; // esi
  unsigned int v3; // edi
  _BOOL2 v4; // dx
  int v5; // esi
  __int16 v6; // dx
  __int16 v7; // bp
  unsigned __int16 v8; // ax
  void *result; // eax
  unsigned int v10; // [esp+10h] [ebp-1Ch]
  __int16 v11; // [esp+18h] [ebp-14h]
  int v12; // [esp+1Ch] [ebp-10h]
  int v13; // [esp+24h] [ebp-8h]

  v0 = (unsigned int)((_DWORD)off_E8F8 * (_DWORD)off_E904) >> 16;
  v1 = v0 + (dword_E910 + (unsigned int)(unsigned __int16)((_WORD)off_E8F8 * (_WORD)off_E904) > 0xFFFF) > 0xFFFF;
  v2 = (unsigned __int16)(v0
                        + (dword_E910 + (unsigned int)(unsigned __int16)((_WORD)off_E8F8 * (_WORD)off_E904) > 0xFFFF));
  v13 = (unsigned __int16)((_WORD)off_E8FC * (_WORD)off_E904);
  v3 = (unsigned int)((_DWORD)off_E8FC * (_DWORD)off_E904) >> 16;
  v4 = (unsigned int)(v13 + v2) > 0xFFFF;
  v5 = (unsigned __int16)(v13 + v2);
  v12 = (unsigned __int16)((_WORD)off_E8F8 * (_WORD)off_E908);
  v10 = (unsigned int)((_DWORD)off_E8F8 * (_DWORD)off_E908) >> 16;
  v6 = v1 + v4;
  v7 = dword_E900 * (_WORD)off_E904;
  v11 = (_WORD)off_E8FC * (_WORD)off_E908;
  if ( (unsigned int)(v12 + v5) <= 0xFFFF )
    v8 = (_WORD)off_E8F8 * dword_E90C + v11 + v7 + v10 + v3 + v6;
  else
    v8 = (_WORD)off_E8F8 * dword_E90C + v11 + v7 + v10 + v6 + v3 + 1;
  dword_E900 = v8;
  result = (void *)(unsigned __int16)(v12 + v5);
  off_E8FC = result;
  off_E8F8 = (_UNKNOWN *)(unsigned __int16)(dword_E910 + (_WORD)off_E8F8 * (_WORD)off_E904);
  return result;
}
// E8F8: using guessed type _UNKNOWN *off_E8F8;
// E8FC: using guessed type _UNKNOWN *off_E8FC;
// E900: using guessed type int dword_E900;
// E904: using guessed type _UNKNOWN *off_E904;
// E908: using guessed type int (*off_E908)[69];
// E90C: using guessed type int dword_E90C;
// E910: using guessed type int dword_E910;

//----- (00001D1C) --------------------------------------------------------
unsigned int __cdecl sub_1D1C(unsigned int a1)
{
  off_E8F8 = &loc_330A + 4;
  off_E8FC = (_UNKNOWN *)(unsigned __int16)a1;
  dword_E900 = HIWORD(a1);
  off_E904 = &unk_E66D;
  off_E908 = (int (*)[69])dword_DEEC;
  dword_E90C = 5;
  dword_E910 = 11;
  return HIWORD(a1);
}
// DEEC: using guessed type int dword_DEEC[69];
// E8F8: using guessed type _UNKNOWN *off_E8F8;
// E8FC: using guessed type _UNKNOWN *off_E8FC;
// E900: using guessed type int dword_E900;
// E904: using guessed type _UNKNOWN *off_E904;
// E908: using guessed type int (*off_E908)[69];
// E90C: using guessed type int dword_E90C;
// E910: using guessed type int dword_E910;

//----- (00001E3C) --------------------------------------------------------
unsigned int __cdecl sub_1E3C(unsigned __int16 *a1)
{
  int v1; // edx
  _DWORD *v2; // eax
  unsigned __int16 *v3; // ecx
  unsigned int v4; // ebx
  int v5; // edx
  unsigned __int16 *v6; // ecx
  unsigned __int16 *v7; // eax
  _DWORD v9[3]; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  v2 = &off_E8F8;
  v3 = a1;
  do
  {
    v9[v1] = *v2;
    *v2++ = *v3++;
    ++v1;
  }
  while ( v1 <= 2 );
  v4 = sub_1B9C();
  v5 = 0;
  v6 = (unsigned __int16 *)&off_E8F8;
  v7 = a1;
  do
  {
    *v7 = *v6;
    *(_DWORD *)v6 = v9[v5];
    v6 += 2;
    ++v7;
    ++v5;
  }
  while ( v5 <= 2 );
  return v4;
}
// E8F8: using guessed type _UNKNOWN *off_E8F8;

//----- (00001E9C) --------------------------------------------------------
int __cdecl sub_1E9C(unsigned __int16 *a1)
{
  int v1; // edx
  _DWORD *v2; // eax
  unsigned __int16 *v3; // ecx
  int v4; // ebx
  int v5; // edx
  unsigned __int16 *v6; // ecx
  unsigned __int16 *v7; // eax
  _DWORD v9[3]; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  v2 = &off_E8F8;
  v3 = a1;
  do
  {
    v9[v1] = *v2;
    *v2++ = *v3++;
    ++v1;
  }
  while ( v1 <= 2 );
  v4 = sub_1BBC();
  v5 = 0;
  v6 = (unsigned __int16 *)&off_E8F8;
  v7 = a1;
  do
  {
    *v7 = *v6;
    *(_DWORD *)v6 = v9[v5];
    v6 += 2;
    ++v7;
    ++v5;
  }
  while ( v5 <= 2 );
  return v4;
}
// E8F8: using guessed type _UNKNOWN *off_E8F8;

//----- (00001EFC) --------------------------------------------------------
int __cdecl sub_1EFC(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_1F2C();
  if ( !v1 )
    return -1;
  *v1 = 2;
  v1[1] = a1;
  return 0;
}

//----- (00001F2C) --------------------------------------------------------
int sub_1F2C()
{
  _DWORD *v0; // ebx
  int v1; // ecx
  int v2; // edx
  int v3; // eax

  v0 = off_EAB0;
  if ( off_EAB0 )
  {
    while ( !v0[1] )
    {
LABEL_6:
      if ( v0[1] <= 0x1Fu )
        return (int)&v0[3 * v0[1]++ + 2];
      v0 = (_DWORD *)*v0;
      if ( !v0 )
        goto LABEL_8;
    }
    v1 = 0;
    while ( 1 )
    {
      v2 = v1 * 4;
      if ( !v0[v1 + 2] )
        return (int)&v0[v1 + 2];
      v1 += 3;
      if ( v2 + 12 >= (unsigned int)(12 * v0[1]) )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_8:
    v3 = sub_2378(0x188u);
    if ( v3 )
    {
      *(_DWORD *)v3 = off_EAB0;
      off_EAB0 = (_UNKNOWN *)v3;
      *(_DWORD *)(v3 + 4) = 1;
      return v3 + 8;
    }
    else
    {
      return 0;
    }
  }
}
// EAB0: using guessed type _UNKNOWN *off_EAB0;

//----- (00001FC4) --------------------------------------------------------
int __cdecl sub_1FC4(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // edx
  char *v4; // edi
  char *v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // ecx

  v3 = a3;
  v4 = (char *)a1;
  v5 = a2;
  if ( a3 > 7 )
  {
    v6 = a3 - (-a1 & 3);
    v7 = -a1 & 3;
    qmemcpy((void *)a1, a2, v7);
    qmemcpy((void *)(a1 + v7), &a2[v7], 4 * (v6 >> 2));
    v5 = &a2[4 * (v6 >> 2) + v7];
    v4 = (char *)(a1 + v7 + 4 * (v6 >> 2));
    v3 = v6 & 3;
  }
  qmemcpy(v4, v5, v3);
  return a1;
}

//----- (00002000) --------------------------------------------------------
int __cdecl sub_2000(int a1, char *a2)
{
  char *v2; // edx
  char v3; // al

  v2 = a2;
  do
  {
    v3 = *v2++;
    v2[a1 - (_DWORD)a2 - 1] = v3;
  }
  while ( v3 );
  return a1;
}

//----- (00002020) --------------------------------------------------------
int __cdecl sub_2020(int signum, int a2)
{
  int v2; // eax
  int v3; // edx
  int v5; // [esp+0h] [ebp-20h] BYREF
  _DWORD v6[4]; // [esp+10h] [ebp-10h] BYREF

  v6[0] = a2;
  v6[1] = 0;
  v6[2] = -536870912;
  v2 = sub_2A30(signum, (const struct sigaction *)v6, (struct sigaction *)&v5);
  v3 = -1;
  if ( v2 != -1 )
    return v5;
  return v3;
}

//----- (0000206C) --------------------------------------------------------
__int16 __cdecl sub_206C(__int16 a1)
{
  __int16 v1; // dx
  __int16 v3; // [esp+2h] [ebp-2h]

  v1 = a1;
  if ( !a1 )
    v1 = 4978;
  return v3 & 0xF0C0 | v1 & 0xF3F;
}
// 2096: variable 'v3' is possibly undefined

//----- (000020AC) --------------------------------------------------------
int __cdecl sub_20AC(int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ebx
  char *v4; // edi
  int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // ecx

  v3 = a3;
  v4 = (char *)a1;
  LOBYTE(v5) = a2;
  if ( a3 > 0xB )
  {
    v5 = a2 | (a2 << 8) | ((a2 | (a2 << 8)) << 16);
    v6 = a3 - (-a1 & 3);
    v7 = -a1 & 3;
    memset((void *)a1, a2, v7);
    memset32((void *)(a1 + v7), v5, v6 >> 2);
    v4 = (char *)(a1 + v7 + 4 * (v6 >> 2));
    v3 = v6 & 3;
  }
  memset(v4, v5, v3);
  return a1;
}

//----- (000020F8) --------------------------------------------------------
const char *__cdecl sub_20F8(const char *a1, char *a2)
{
  char *v3; // edi
  char v4; // al

  v3 = (char *)&a1[strlen(a1)];
  do
  {
    v4 = *a2++;
    *v3++ = v4;
  }
  while ( v4 );
  return a1;
}

//----- (0000211C) --------------------------------------------------------
int __cdecl sub_211C(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  int v5; // ecx
  unsigned __int8 v6; // al
  bool v7; // cf
  int result; // eax

  v5 = a3 + 1;
  while ( 1 )
  {
    if ( !--v5 )
      return 0;
    v6 = *a2++;
    v7 = *a1 < v6;
    if ( *a1++ != v6 )
      break;
    if ( !v6 )
      return 0;
  }
  result = 1;
  if ( !v7 )
    return -1;
  return result;
}

//----- (00002148) --------------------------------------------------------
int __cdecl sub_2148(int a1)
{
  int v1; // esi
  int v2; // ebx

  v1 = off_EAC0(a1);
  if ( (v1 & 0xFFF) != 0 )
  {
    v2 = 4096 - (v1 & 0xFFF);
    off_EAC0(v2);
    v1 += v2;
  }
  return v1;
}
// EAC0: using guessed type int (__cdecl *off_EAC0)(int a1);

//----- (00002188) --------------------------------------------------------
int sub_2188()
{
  int v0; // edx
  int v1; // eax

  dword_EE94 = 1024;
  v0 = sub_2148(12288);
  dword_EEC8 = v0;
  if ( !v0 )
    return 0;
  sub_20AC(v0, 0, 12 * dword_EE94);
  v1 = dword_EEC8;
  *(_DWORD *)dword_EEC8 = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 4) = 0;
  dword_EED0 = 0;
  dword_EECC = v1;
  dword_EE98 = 1;
  return 1;
}
// EE94: using guessed type int dword_EE94;
// EE98: using guessed type int dword_EE98;
// EEC8: using guessed type int dword_EEC8;
// EECC: using guessed type int dword_EECC;
// EED0: using guessed type int dword_EED0;

//----- (00002218) --------------------------------------------------------
int __cdecl sub_2218(int a1)
{
  int v1; // eax
  int v2; // ebp
  int v4; // edx
  int v5; // eax
  int i; // ebx
  int v7; // eax
  int v8; // edi
  _DWORD *v9; // esi
  int v10; // edx

  v1 = sub_2148(a1);
  v2 = v1;
  if ( !v1 )
    return 0;
  v4 = v1 + a1;
  v5 = v1 + a1 - dword_EECC;
  if ( v2 + a1 - dword_EECC < 0 )
    v5 += 4095;
  if ( dword_EE94 < (v5 >> 12) + 1 )
  {
    for ( i = dword_EE94; (v4 - dword_EECC) / 4096 + 1 > i; i *= 2 )
      ;
    v7 = sub_2148(12 * i);
    v8 = v7;
    if ( !v7 )
    {
      off_EAC0(-a1);
      return 0;
    }
    sub_20AC(v7, 0, 12 * i);
    sub_1FC4(v8, (char *)dword_EEC8, 12 * dword_EE94);
    v9 = (_DWORD *)dword_EEC8;
    v10 = dword_EEC8 - dword_EECC;
    *(_DWORD *)(v8 + 12 * ((dword_EEC8 - dword_EECC) / 4096) + 12) = 0;
    *(_DWORD *)(v8 + 12 * (v10 / 4096) + 16) = (unsigned int)(12 * dword_EE94 + 4095) >> 12;
    dword_EEC8 = v8;
    sub_26E8(v9);
    dword_EE94 = i;
  }
  dword_EED4 = (v2 + a1 - dword_EECC) / 4096 + 1;
  return v2;
}
// EAC0: using guessed type int (__cdecl *off_EAC0)(int a1);
// EE94: using guessed type int dword_EE94;
// EEC8: using guessed type int dword_EEC8;
// EECC: using guessed type int dword_EECC;
// EED4: using guessed type int dword_EED4;

//----- (00002378) --------------------------------------------------------
int __cdecl sub_2378(unsigned int a1)
{
  unsigned int v1; // ebx
  unsigned int v3; // ebx
  int j; // esi
  int v5; // ebp
  int v6; // ebx
  int v7; // edx
  int k; // edx
  _DWORD *v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // ebx
  int v15; // ebp
  int i; // edx
  int v17; // ebx
  int v18; // esi
  int v19; // ebx
  int v20; // esi
  int v21; // eax
  int v22; // ebp
  int v23; // edx
  int v24; // eax
  int v25; // esi
  int v26; // eax
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // [esp+10h] [ebp-10h]
  _DWORD **v33; // [esp+14h] [ebp-Ch]
  signed int v34; // [esp+1Ch] [ebp-4h]

  v1 = a1;
  if ( !dword_EE98 && !sub_2188() || !a1 )
    return 0;
  if ( a1 <= 7 )
    v1 = 8;
  if ( v1 > 0x800 )
  {
    v34 = (v1 + 4095) >> 12;
    v14 = dword_EED0;
    v15 = dword_EED0;
    for ( i = dword_EEC8; *(_DWORD *)(dword_EEC8 + 12 * v14) < v34; i = dword_EEC8 )
    {
      v14 = *(_DWORD *)(i + 12 * v14 + 4);
      if ( v14 == v15 )
      {
        v17 = *(_DWORD *)(i + 8);
        v18 = *(_DWORD *)(i + 12 * v17);
        if ( !dword_EED4
          || (v19 = v18 + v17, dword_EED4 != v19)
          || off_EAC0(0) != dword_EECC + ((v19 - 1) << 12)
          || (v20 = v34 - v18, !sub_2218(v20 << 12)) )
        {
          v21 = sub_2218(v34 << 12);
          v22 = v21;
          if ( v21 )
          {
            v23 = dword_EEC8;
            v24 = 4 * (3 * ((v21 - dword_EECC) / 4096) + 3);
            *(_DWORD *)(dword_EEC8 + v24) = 0;
            *(_DWORD *)(v23 + v24 + 4) = v34;
            return v22;
          }
          return 0;
        }
        v14 = *(_DWORD *)(dword_EEC8 + 8);
        *(_DWORD *)(dword_EEC8 + 12 * v14) += v20;
      }
    }
    v5 = dword_EECC + ((v14 - 1) << 12);
    v25 = dword_EEC8;
    v32 = 12 * v14;
    if ( *(_DWORD *)(dword_EEC8 + 12 * v14) <= v34 )
    {
      *(_DWORD *)(dword_EEC8 + 12 * *(_DWORD *)(dword_EEC8 + v32 + 4) + 8) = *(_DWORD *)(dword_EEC8 + v32 + 8);
      v29 = 3 * *(_DWORD *)(v25 + v32 + 8);
      dword_EED0 = *(_DWORD *)(v25 + v32 + 4);
      *(_DWORD *)(v25 + 4 * v29 + 4) = dword_EED0;
    }
    else
    {
      v26 = 12 * (v14 + v34);
      *(_DWORD *)(dword_EEC8 + v26) = *(_DWORD *)(dword_EEC8 + 12 * v14) - v34;
      *(_DWORD *)(v25 + v26 + 4) = *(_DWORD *)(v25 + v32 + 4);
      *(_DWORD *)(v25 + v26 + 8) = *(_DWORD *)(v25 + v32 + 8);
      v27 = 3 * *(_DWORD *)(v25 + v32 + 8);
      v28 = 3 * *(_DWORD *)(v25 + v32 + 4);
      dword_EED0 = v14 + v34;
      *(_DWORD *)(v25 + 4 * v28 + 8) = v14 + v34;
      *(_DWORD *)(v25 + 4 * v27 + 4) = v14 + v34;
    }
    v30 = dword_EEC8;
    v31 = 12 * v14;
    *(_DWORD *)(dword_EEC8 + v31) = 0;
    *(_DWORD *)(v30 + v31 + 4) = v34;
  }
  else
  {
    v3 = v1 - 1;
    for ( j = 1; ; ++j )
    {
      v3 >>= 1;
      if ( !v3 )
        break;
    }
    v33 = (_DWORD **)dword_EED8[2 * j];
    if ( v33 )
    {
      v5 = dword_EED8[2 * j];
      *v33[1] = *v33;
      if ( *v33 )
        (*v33)[1] = v33[1];
      v6 = dword_EEC8;
      v7 = 4 * (3 * (((int)v33 - dword_EECC) / 4096) + 3);
      if ( (*(_DWORD *)(dword_EEC8 + v7 + 4))-- != 1 )
        *(_DWORD *)(v6 + v7 + 8) = ((unsigned int)*v33 & 0xFFF) >> j;
    }
    else
    {
      v5 = sub_2378(4096);
      if ( !v5 )
        return 0;
      ++dword_F808[j];
      for ( k = 1; 4096 >> j > k; ++k )
      {
        v10 = (_DWORD *)(v5 + (k << j));
        *v10 = dword_EED8[2 * j];
        v10[1] = 8 * j + 61144;
        dword_EED8[2 * j] = v10;
        if ( *v10 )
          *(_DWORD *)(*v10 + 4) = v10;
      }
      v11 = dword_EEC8;
      v12 = 4 * (3 * ((v5 - dword_EECC) / 4096) + 3);
      *(_DWORD *)(dword_EEC8 + v12) = j;
      v13 = k - 1;
      *(_DWORD *)(v11 + v12 + 4) = v13;
      *(_DWORD *)(v11 + v12 + 8) = v13;
    }
  }
  return v5;
}
// EAC0: using guessed type int (__cdecl *off_EAC0)(int a1);
// EE98: using guessed type int dword_EE98;
// EEC8: using guessed type int dword_EEC8;
// EECC: using guessed type int dword_EECC;
// EED0: using guessed type int dword_EED0;
// EED4: using guessed type int dword_EED4;
// EED8: using guessed type _DWORD dword_EED8[24];
// F808: using guessed type int dword_F808[12];

//----- (000026E8) --------------------------------------------------------
void __cdecl sub_26E8(_DWORD *a1)
{
  int v1; // esi
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // ebx
  int v6; // eax
  int v7; // edx
  int v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // ebp
  _DWORD *v14; // ecx
  int i; // edx
  int v16; // eax
  int v17; // edx
  int v18; // edx
  int v19; // ebp
  int v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  int v22; // [esp+14h] [ebp-8h]

  if ( a1 )
  {
    v1 = ((int)a1 - dword_EECC) / 4096 + 1;
    v20 = v1;
    v21 = 12 * v1;
    v2 = *(_DWORD *)(dword_EEC8 + 12 * v1);
    if ( v2 )
    {
      v12 = (*(_DWORD *)(dword_EEC8 + v21 + 8) << v2) + dword_EECC + ((((int)a1 - dword_EECC) / 4096) << 12);
      v13 = 4096 >> v2;
      if ( *(_DWORD *)(dword_EEC8 + v21 + 4) == (4096 >> v2) - 1 && dword_F808[v2] > 1 )
      {
        --dword_F808[v2];
        v14 = (_DWORD *)v12;
        for ( i = 1; i < v13; ++i )
          v14 = (_DWORD *)*v14;
        **(_DWORD **)(v12 + 4) = v14;
        if ( v14 )
          v14[1] = *(_DWORD *)(v12 + 4);
        v16 = dword_EEC8;
        v17 = 12 * v1;
        *(_DWORD *)(dword_EEC8 + v17) = 0;
        *(_DWORD *)(v16 + v17 + 4) = 1;
        sub_26E8(dword_EECC + ((v1 - 1) << 12));
      }
      else
      {
        v18 = dword_EEC8;
        v19 = 12 * v1;
        if ( *(_DWORD *)(dword_EEC8 + 12 * v1 + 4) )
        {
          *a1 = *(_DWORD *)v12;
          a1[1] = v12;
          *(_DWORD *)v12 = a1;
          if ( *a1 )
            *(_DWORD *)(*a1 + 4) = a1;
          ++*(_DWORD *)(dword_EEC8 + v19 + 4);
        }
        else
        {
          *(_DWORD *)(dword_EEC8 + v19 + 4) = 1;
          *(_DWORD *)(v18 + v19 + 8) = (unsigned __int16)((unsigned __int16)a1 & 0xFFF) >> v2;
          *a1 = dword_EED8[2 * v2];
          a1[1] = 8 * v2 + 61144;
          dword_EED8[2 * v2] = a1;
          if ( *a1 )
            *(_DWORD *)(*a1 + 4) = a1;
        }
      }
    }
    else
    {
      v3 = dword_EED0;
      if ( dword_EED0 <= v1 )
      {
        do
          v3 = *(_DWORD *)(dword_EEC8 + 12 * v3 + 4);
        while ( v3 > 0 && v1 > v3 );
        v3 = *(_DWORD *)(dword_EEC8 + 12 * v3 + 8);
      }
      else
      {
        do
          v3 = *(_DWORD *)(dword_EEC8 + 12 * v3 + 8);
        while ( v1 < v3 );
      }
      v4 = dword_EEC8;
      v5 = 12 * v3;
      if ( v1 == *(_DWORD *)(dword_EEC8 + 12 * v3) + v3 )
      {
        *(_DWORD *)(dword_EEC8 + 12 * v3) += *(_DWORD *)(dword_EEC8 + 12 * v1 + 4);
        v20 = v3;
      }
      else
      {
        v6 = 12 * v1;
        *(_DWORD *)(dword_EEC8 + v6) = *(_DWORD *)(dword_EEC8 + 12 * v1 + 4);
        *(_DWORD *)(v4 + v6 + 4) = *(_DWORD *)(v4 + v5 + 4);
        *(_DWORD *)(v4 + v6 + 8) = v3;
        *(_DWORD *)(v4 + v5 + 4) = v1;
        *(_DWORD *)(v4 + 12 * *(_DWORD *)(v4 + v6 + 4) + 8) = v1;
      }
      v7 = dword_EEC8;
      v8 = 12 * v20;
      v9 = *(_DWORD *)(dword_EEC8 + 12 * v20) + v20;
      if ( *(_DWORD *)(dword_EEC8 + 12 * v20 + 4) == v9 )
      {
        *(_DWORD *)(dword_EEC8 + 12 * v20) += *(_DWORD *)(dword_EEC8 + 12 * v9);
        *(_DWORD *)(v7 + v8 + 4) = *(_DWORD *)(v7 + 12 * *(_DWORD *)(v7 + v8 + 4) + 4);
        *(_DWORD *)(v7 + 12 * *(_DWORD *)(v7 + v8 + 4) + 8) = v20;
      }
      v10 = *(_DWORD *)(dword_EEC8 + 12 * v20);
      v22 = v10;
      if ( v10 > 7 && dword_EED4 == v10 + v20 && off_EAC0(0) == dword_EECC + ((v10 + v20 - 1) << 12) )
      {
        dword_EED4 -= v22;
        off_EAC0(-4096 * v22);
        v11 = dword_EEC8;
        *(_DWORD *)(dword_EEC8 + 12 * *(_DWORD *)(dword_EEC8 + v8 + 8) + 4) = *(_DWORD *)(dword_EEC8 + v8 + 4);
        *(_DWORD *)(v11 + 12 * *(_DWORD *)(v11 + v8 + 4) + 8) = *(_DWORD *)(v11 + v8 + 8);
        v20 = *(_DWORD *)(v11 + v8 + 8);
      }
      dword_EED0 = v20;
    }
  }
}
// EAC0: using guessed type int (__cdecl *off_EAC0)(int a1);
// EEC8: using guessed type int dword_EEC8;
// EECC: using guessed type int dword_EECC;
// EED0: using guessed type int dword_EED0;
// EED4: using guessed type int dword_EED4;
// EED8: using guessed type _DWORD[24];
// F808: using guessed type int dword_F808[12];

//----- (000029F4) --------------------------------------------------------
int __cdecl sub_29F4(int a1, int a2, int a3)
{
  unsigned int v3; // ebx
  int (__cdecl **v4)(_DWORD, _DWORD, _DWORD); // esi
  int result; // eax

  v3 = 0;
  if ( dword_EF38 )
  {
    v4 = (int (__cdecl **)(_DWORD, _DWORD, _DWORD))algn_EF3C;
    do
    {
      result = (*v4++)(a1, a2, a3);
      ++v3;
    }
    while ( dword_EF38 > v3 );
  }
  return result;
}
// EF38: using guessed type int dword_EF38;
// EF3C: using guessed type _BYTE[196];

//----- (00002A30) --------------------------------------------------------
int __cdecl sub_2A30(int signum, const struct sigaction *act, struct sigaction *old)
{
  int v3; // eax

  if ( act )
  {
    if ( (act->sa_mask.__val[1] & 0x40000000) != 0 )
      act->sa_mask.__val[2] = 21820;
    else
      act->sa_mask.__val[2] = 21828;
  }
  v3 = sys_sigaction(signum, act, old);
  if ( v3 >= 0 )
    return 0;
  dword_E924 = -v3;
  return -1;
}
// E924: using guessed type int dword_E924;

//----- (00002E94) --------------------------------------------------------
unsigned __int8 *__cdecl sub_2E94(char *a1)
{
  unsigned int v1; // kr04_4
  int v2; // edi
  unsigned __int8 **v3; // ebx

  v1 = strlen(a1) + 1;
  v2 = v1 - 1;
  v3 = (unsigned __int8 **)dword_E920;
  if ( !*(_DWORD *)dword_E920 )
    return 0;
  while ( sub_211C(*v3, (unsigned __int8 *)a1, v2) || (*v3)[v2] != 61 )
  {
    if ( !*++v3 )
      return 0;
  }
  return &(*v3)[v1];
}
// E920: using guessed type int dword_E920;

//----- (00002EF4) --------------------------------------------------------
int __cdecl sub_2EF4(int a1)
{
  int v1; // edi
  int v2; // eax
  int v3; // esi
  int v4; // ecx
  int v5; // esi
  int i; // ecx
  int result; // eax
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  int v11; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v1 = dword_EEA4;
  v12 = dword_EEA8;
  v11 = dword_EBD4;
  while ( v11 > v12 && v12 > v1 )
  {
    v2 = v12 - v1;
    if ( v11 - v12 <= v12 - v1 )
    {
      v5 = v11 - v12;
      for ( i = 0; i < v5; ++i )
      {
        v9 = *(_DWORD *)(a1 + 4 * (i + v1));
        *(_DWORD *)(a1 + 4 * (i + v1)) = *(_DWORD *)(a1 + 4 * (i + v12));
        *(_DWORD *)(a1 + 4 * (i + v12)) = v9;
      }
      v1 += v5;
    }
    else
    {
      v3 = v12 - v1;
      v4 = 0;
      if ( v2 > 0 )
      {
        v10 = v11 - v2;
        do
        {
          v8 = *(_DWORD *)(a1 + 4 * (v4 + v1));
          *(_DWORD *)(a1 + 4 * (v4 + v1)) = *(_DWORD *)(a1 + 4 * (v4 + v10));
          *(_DWORD *)(a1 + 4 * (v4 + v10)) = v8;
          ++v4;
        }
        while ( v4 < v3 );
      }
      v11 -= v3;
    }
  }
  result = dword_EBD4 - dword_EEA8;
  dword_EEA4 += dword_EBD4 - dword_EEA8;
  dword_EEA8 = dword_EBD4;
  return result;
}
// EBD4: using guessed type int dword_EBD4;
// EEA4: using guessed type int dword_EEA4;
// EEA8: using guessed type int dword_EEA8;

//----- (00003124) --------------------------------------------------------
int __usercall sub_3124@<eax>(_BYTE *a1@<ebp>, int a2, int *a3, char *a4, const char **a5, _DWORD *a6, int a7)
{
  const char **v7; // ebx
  _BYTE *v8; // esi
  _BYTE *v9; // esi
  _BOOL4 v11; // edi
  _BYTE *v12; // esi
  _BYTE *v13; // esi
  int v14; // ebp
  char *v15; // ebx
  int v16; // ebx
  char *v17; // ebx
  char v18; // bl
  char *v19; // eax
  int v20; // [esp-Ch] [ebp-3Ch]
  int v21; // [esp-Ch] [ebp-3Ch]
  int v22; // [esp-8h] [ebp-38h]
  int v23; // [esp-8h] [ebp-38h]
  int v24; // [esp-8h] [ebp-38h]
  int v25; // [esp-8h] [ebp-38h]
  int v26; // [esp-8h] [ebp-38h]
  int v27; // [esp-8h] [ebp-38h]
  int v28; // [esp-8h] [ebp-38h]
  int v29; // [esp-8h] [ebp-38h]
  int v30; // [esp-4h] [ebp-34h]
  const char *v31; // [esp-4h] [ebp-34h]
  int v32; // [esp-4h] [ebp-34h]
  int v33; // [esp-4h] [ebp-34h]
  int v34; // [esp+1Ch] [ebp-14h]
  int v35; // [esp+1Ch] [ebp-14h]
  int v36; // [esp+1Ch] [ebp-14h]
  int v37; // [esp+1Ch] [ebp-14h]
  int v38; // [esp+1Ch] [ebp-14h]
  int v39; // [esp+1Ch] [ebp-14h]
  int v40; // [esp+1Ch] [ebp-14h]
  int v41; // [esp+1Ch] [ebp-14h]
  int v42; // [esp+20h] [ebp-10h]
  const char **v43; // [esp+24h] [ebp-Ch]
  int v44; // [esp+28h] [ebp-8h]
  int v45; // [esp+2Ch] [ebp-4h]

  v7 = a5;
  dword_EBD0 = 0;
  sub_4734(a1);
  if ( !dword_EBD4 )
  {
    dword_EBD4 = 1;
    dword_EEA8 = 1;
    dword_EEA4 = 1;
    dword_EE9C = 0;
    if ( *a4 == 45 )
    {
      dword_EEA0 = 2;
      ++a4;
    }
    else if ( *a4 == 43 )
    {
      dword_EEA0 = 0;
      ++a4;
    }
    else
    {
      dword_EEA0 = sub_2E94("POSIXLY_CORRECT") == 0;
    }
  }
  if ( dword_EE9C && *(_BYTE *)dword_EE9C )
  {
LABEL_40:
    if ( a5 )
    {
      v12 = (_BYTE *)a3[dword_EBD4];
      if ( *v12 == 45 && (v12[1] == 45 || a7) )
      {
        v13 = (_BYTE *)dword_EE9C;
        v45 = 0;
        v44 = 0;
        v43 = 0;
        while ( *v13 && *v13 != 61 )
          ++v13;
        v14 = 0;
        if ( *a5 )
        {
          do
          {
            if ( !sub_211C((unsigned __int8 *)*v7, (unsigned __int8 *)dword_EE9C, (int)&v13[-dword_EE9C]) )
            {
              if ( &v13[-dword_EE9C] == (_BYTE *)strlen(*v7) )
              {
                v43 = v7;
                v42 = v14;
                v45 = 1;
                break;
              }
              if ( v43 )
              {
                v44 = 1;
              }
              else
              {
                v43 = v7;
                v42 = v14;
              }
            }
            v7 += 4;
            ++v14;
          }
          while ( *v7 );
        }
        if ( v44 && !v45 )
        {
          if ( dword_EBD8 )
          {
            v30 = a3[dword_EBD4];
            v22 = *a3;
            v34 = sub_4290(dword_EBF8, 6, 1, 12287);
            sub_7514(dword_EB78, v34, v22, v30);
          }
          dword_EE9C += strlen((const char *)dword_EE9C);
LABEL_60:
          ++dword_EBD4;
          return 63;
        }
        if ( v43 )
        {
          ++dword_EBD4;
          if ( *v13 )
          {
            if ( !v43[1] )
            {
              if ( dword_EBD8 )
              {
                v15 = (char *)a3[dword_EBD4 - 1];
                v31 = *v43;
                if ( v15[1] == 45 )
                {
                  v23 = *a3;
                  v35 = sub_4290(dword_EBF8, 6, 2, 12317);
                  sub_7514(dword_EB78, v35, v23, v31);
                }
                else
                {
                  v24 = *v15;
                  v20 = *a3;
                  v36 = sub_4290(dword_EBF8, 6, 3, 12362);
                  sub_7514(dword_EB78, v36, v20, v24, v31);
                }
              }
              dword_EE9C += strlen((const char *)dword_EE9C);
              return 63;
            }
            dword_EBD0 = (int)(v13 + 1);
          }
          else if ( v43[1] == (_BYTE *)start + 1 )
          {
            if ( dword_EBD4 >= a2 )
            {
              if ( dword_EBD8 )
              {
                v32 = a3[dword_EBD4 - 1];
                v25 = *a3;
                v37 = sub_4290(dword_EBF8, 6, 4, 12407);
                sub_7514(dword_EB78, v37, v25, v32);
              }
              dword_EE9C += strlen((const char *)dword_EE9C);
              v16 = 63;
              if ( *a4 == 58 )
                return 58;
              return v16;
            }
            dword_EBD0 = a3[dword_EBD4++];
          }
          dword_EE9C += strlen((const char *)dword_EE9C);
          if ( a6 )
            *a6 = v42;
          if ( !v43[2] )
            return (int)v43[3];
          *(_DWORD *)v43[2] = v43[3];
          return 0;
        }
        if ( !a7 || *(_BYTE *)(a3[dword_EBD4] + 1) == 45 || !sub_5554(a4, *(_BYTE *)dword_EE9C) )
        {
          if ( dword_EBD8 )
          {
            v17 = (char *)a3[dword_EBD4];
            v33 = dword_EE9C;
            if ( v17[1] == 45 )
            {
              v26 = *a3;
              v38 = sub_4290(dword_EBF8, 6, 6, 12445);
              sub_7514(dword_EB78, v38, v26, v33);
            }
            else
            {
              v27 = *v17;
              v21 = *a3;
              v39 = sub_4290(dword_EBF8, 6, 7, 12477);
              sub_7514(dword_EB78, v39, v21, v27, v33);
            }
          }
          dword_EE9C = 12509;
          goto LABEL_60;
        }
      }
    }
    v18 = *(_BYTE *)dword_EE9C++;
    v19 = sub_5554(a4, v18);
    if ( !*(_BYTE *)dword_EE9C )
      ++dword_EBD4;
    if ( !v19 || v18 == 58 )
    {
      if ( dword_EBD8 )
      {
        v28 = *a3;
        v40 = sub_4290(dword_EBF8, 6, 8, 12510);
        sub_7514(dword_EB78, v40, v28, v18);
      }
      dword_EBDC = v18;
      return 63;
    }
    if ( v19[1] != 58 )
      return v18;
    if ( v19[2] == 58 )
    {
      if ( !*(_BYTE *)dword_EE9C )
      {
        dword_EBD0 = 0;
LABEL_112:
        dword_EE9C = 0;
        return v18;
      }
      dword_EBD0 = dword_EE9C;
    }
    else if ( *(_BYTE *)dword_EE9C )
    {
      dword_EBD0 = dword_EE9C;
    }
    else
    {
      if ( dword_EBD4 == a2 )
      {
        if ( dword_EBD8 )
        {
          v29 = *a3;
          v41 = sub_4290(dword_EBF8, 6, 5, 12536);
          sub_7514(dword_EB78, v41, v29, v18);
        }
        dword_EBDC = v18;
        v18 = 63;
        if ( *a4 == 58 )
          v18 = 58;
        goto LABEL_112;
      }
      dword_EBD0 = a3[dword_EBD4];
    }
    ++dword_EBD4;
    goto LABEL_112;
  }
  if ( dword_EEA0 == 1 )
  {
    if ( dword_EEA8 == dword_EEA4 )
    {
      if ( dword_EBD4 != dword_EEA4 )
        dword_EEA4 = dword_EBD4;
    }
    else if ( dword_EBD4 != dword_EEA8 )
    {
      sub_2EF4((int)a3);
    }
    while ( dword_EBD4 < a2 )
    {
      v8 = (_BYTE *)a3[dword_EBD4];
      if ( *v8 == 45 )
      {
        if ( v8[1] )
          break;
      }
      ++dword_EBD4;
    }
    dword_EEA8 = dword_EBD4;
  }
  if ( dword_EBD4 == a2 )
    goto LABEL_29;
  if ( !memcmp((const void *)a3[dword_EBD4], "--", 3u) )
  {
    ++dword_EBD4;
    if ( dword_EEA8 != dword_EEA4 )
    {
      if ( dword_EBD4 != dword_EEA8 )
      {
        sub_2EF4((int)a3);
LABEL_27:
        dword_EEA8 = a2;
        dword_EBD4 = a2;
        goto LABEL_28;
      }
      if ( dword_EEA8 != dword_EEA4 )
        goto LABEL_27;
    }
    dword_EEA4 = dword_EBD4;
    goto LABEL_27;
  }
LABEL_28:
  if ( dword_EBD4 == a2 )
  {
LABEL_29:
    if ( dword_EEA8 != dword_EEA4 )
      dword_EBD4 = dword_EEA4;
    return -1;
  }
  v9 = (_BYTE *)a3[dword_EBD4];
  if ( *v9 == 45 && v9[1] )
  {
    v11 = 0;
    if ( a5 )
      v11 = v9[1] == 45;
    dword_EE9C = a3[dword_EBD4] + v11 + 1;
    goto LABEL_40;
  }
  if ( !dword_EEA0 )
    return -1;
  dword_EBD0 = a3[dword_EBD4++];
  return 1;
}
// 375C: variable 'v42' is possibly undefined
// 0: using guessed type void __cdecl __noreturn start(int, int);
// EB78: using guessed type _DWORD dword_EB78[20];
// EBD0: using guessed type int dword_EBD0;
// EBD4: using guessed type int dword_EBD4;
// EBD8: using guessed type int dword_EBD8;
// EBDC: using guessed type int dword_EBDC;
// EBF8: using guessed type int dword_EBF8;
// EE9C: using guessed type int dword_EE9C;
// EEA0: using guessed type int dword_EEA0;
// EEA4: using guessed type int dword_EEA4;
// EEA8: using guessed type int dword_EEA8;

//----- (000039F4) --------------------------------------------------------
int __usercall sub_39F4@<eax>(_BYTE *a1@<ebp>, int a2, int *a3, char *a4)
{
  return sub_3124(a1, a2, a3, a4, 0, 0, 0);
}

//----- (00003A14) --------------------------------------------------------
void __cdecl __noreturn sub_3A14(int status)
{
  _DWORD *v1; // edi
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  char *v5; // edx
  int v6; // eax
  int v7; // eax

  v1 = off_EAB0;
  if ( off_EAB0 )
  {
    do
    {
      v2 = v1[1];
      v3 = v2 - 1;
      if ( v2 )
      {
        v4 = 12 * v3 + 8;
        do
        {
          v5 = (char *)v1 + v4;
          v6 = *(_DWORD *)((char *)v1 + v4);
          if ( v6 == 1 )
          {
            (*((void (__cdecl **)(int, _DWORD))v5 + 1))(status, *((_DWORD *)v5 + 2));
          }
          else if ( v6 == 2 )
          {
            (*((void (**)(void))v5 + 1))();
          }
          v7 = v3;
          v4 -= 12;
          --v3;
        }
        while ( v7 );
      }
      v1 = (_DWORD *)*v1;
    }
    while ( v1 );
  }
  sub_71F0();
  sub_3CF0(status);
}
// EAB0: using guessed type _UNKNOWN *off_EAB0;

//----- (00003A84) --------------------------------------------------------
void __cdecl __noreturn sub_3A84(int status)
{
  int v1; // eax

  v1 = sys_exit(status);
}

//----- (00003AB4) --------------------------------------------------------
int __cdecl sub_3AB4(const char *libname)
{
  int result; // eax

  result = sys_uselib(libname);
  if ( result < 0 )
  {
    dword_EBE0 = -result;
    return -1;
  }
  return result;
}
// EBE0: using guessed type int dword_EBE0;

//----- (00003AE4) --------------------------------------------------------
int __cdecl sub_3AE4(int fd, const void *addr, size_t len)
{
  int result; // eax

  result = sys_write(fd, addr, len);
  if ( result < 0 )
  {
    dword_EBE0 = -result;
    return -1;
  }
  return result;
}
// EBE0: using guessed type int dword_EBE0;

//----- (00003B24) --------------------------------------------------------
int __cdecl sub_3B24(void *addr, int len)
{
  int result; // eax

  result = sys_munmap(addr, len);
  if ( result < 0 )
  {
    dword_EBE0 = -result;
    return -1;
  }
  return result;
}
// EBE0: using guessed type int dword_EBE0;

//----- (00003BA4) --------------------------------------------------------
void __cdecl sub_3BA4(int a1, const void **a2, int a3)
{
  _BYTE *v3; // eax
  int v4; // eax
  void *v5[2]; // [esp+10h] [ebp-38h] BYREF
  _BYTE addr[40]; // [esp+18h] [ebp-30h] BYREF
  char v7[4]; // [esp+40h] [ebp-8h] BYREF
  int v8; // [esp+44h] [ebp-4h]

  if ( dword_EE68 )
  {
    v8 = 1659895840;
    if ( sub_3AB4("/lib/ld.so") )
    {
      v3 = *a2;
      qmemcpy(addr, ": can't load dynamic linker '/lib/ld.so'\n", sizeof(addr));
      strcpy(v7, "\n");
      if ( v3 )
      {
        for ( ; *v3; ++v3 )
          ;
        sub_3AE4(2, *a2, v3 - (_BYTE *)*a2);
      }
      sub_3AE4(2, addr, 0x2Au);
      sub_3A84(128);
    }
    v4 = 2;
    if ( a1 <= 0 )
      v4 = 1;
    ((void (__cdecl *)(int, void **, const void *, int, int, int))v8)(v4, v5, *a2, a3, 61024, 61036);
    sub_3B24(v5[0], (int)v5[1]);
  }
  else
  {
    qmemcpy(addr, "\tstatically linked\n", 0x14u);
    if ( a1 > 0 )
      return;
    sub_3AE4(2, addr, 0x14u);
  }
  if ( a1 <= 0 )
    sub_3A84(0);
}
// EE68: using guessed type int dword_EE68;

//----- (00003CF0) --------------------------------------------------------
void __cdecl __noreturn sub_3CF0(int status)
{
  int v1; // eax

  v1 = sys_exit(status);
}

//----- (00003D60) --------------------------------------------------------
int __usercall sub_3D60@<eax>(_BYTE *a1@<ebp>, char *a2, int a3)
{
  char *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // kr08_4
  unsigned int v6; // ecx
  _BYTE *v8; // esi
  struct timespec *p_st_mtim; // ebx
  const char *v10; // edi
  _DWORD *v11; // [esp+18h] [ebp-450h]
  char *v12; // [esp+1Ch] [ebp-44Ch]
  char *v13; // [esp+20h] [ebp-448h]
  char *path; // [esp+24h] [ebp-444h]
  struct stat buf; // [esp+28h] [ebp-440h] BYREF

  path = 0;
  v13 = 0;
  if ( !a2 || !*a2 )
    return -1;
  if ( *a2 != 47 )
  {
    v12 = sub_5744(64, 0);
    if ( !v12 )
      v12 = (_BYTE *)&unk_3D00;
    v3 = (char *)sub_2E94("NLSPATH");
    if ( !v3 )
      v3 = "/etc/locale/%L/%N.cat:/usr/lib/locale/%L/%N.cat:/usr/lib/locale/%N/%L";
    if ( dword_EBF0 )
    {
      v4 = strlen(v3) + 1 + strlen((const char *)dword_EBF0) + 2;
      if ( !v4 )
        v4 = 1;
      v13 = (char *)sub_2378(v4);
      if ( !v13 )
        return -1;
      sub_2000((int)v13, v3);
      if ( v13[strlen(v13) - 1] != 58 && *(_BYTE *)dword_EBF0 != 58 )
        sub_20F8(v13, (char *)sub_3D50);
      sub_20F8(v13, (char *)dword_EBF0);
      v3 = v13;
    }
    v5 = strlen(v3) + 1;
    v6 = v5 + 1;
    if ( v5 == -1 )
      v6 = 1;
    a1 = (_BYTE *)sub_2378(v6);
    v11 = a1;
    if ( !a1 )
      return -1;
    sub_2000((int)a1, v3);
    a1[v5 - 1] = 58;
    a1[v5] = 0;
    v8 = a1;
    if ( !*a1 )
      goto LABEL_39;
    while ( 1 )
    {
      if ( *a1 == 58 )
      {
        *a1 = 0;
        p_st_mtim = &buf.st_mtim;
        if ( *v8 )
        {
          while ( *v8 == 37 )
          {
            if ( v8[1] == 76 )
            {
              ++v8;
              sub_2000((int)p_st_mtim, v12);
              v10 = v12;
            }
            else
            {
              if ( v8[1] != 78 )
              {
                LOBYTE(p_st_mtim->tv_sec) = 37;
LABEL_34:
                p_st_mtim = (struct timespec *)((char *)p_st_mtim + 1);
                goto LABEL_35;
              }
              ++v8;
              sub_2000((int)p_st_mtim, a2);
              v10 = a2;
            }
            p_st_mtim = (struct timespec *)((char *)p_st_mtim + strlen(v10));
LABEL_35:
            if ( !*++v8 )
              goto LABEL_36;
          }
          LOBYTE(p_st_mtim->tv_sec) = *v8;
          goto LABEL_34;
        }
LABEL_36:
        LOBYTE(p_st_mtim->tv_sec) = 0;
        if ( !sub_5654((const char *)&buf.st_mtim, &buf) )
        {
          path = (char *)&buf.st_mtim;
LABEL_39:
          sub_26E8(v11);
          if ( v13 )
            sub_26E8(v13);
          if ( !path )
            return -1;
          return sub_43C0((off_t)a1, path, a3, (int)&buf);
        }
        v8 = a1 + 1;
      }
      if ( !*++a1 )
        goto LABEL_39;
    }
  }
  path = a2;
  if ( sub_5654(a2, &buf) )
    return -1;
  return sub_43C0((off_t)a1, path, a3, (int)&buf);
}
// 3D50: using guessed type int sub_3D50();
// EBF0: using guessed type int dword_EBF0;

//----- (000040B0) --------------------------------------------------------
int *__cdecl sub_40B0(int a1, int a2)
{
  int v3; // ebp
  int v4; // ecx
  int v5; // esi
  int v6; // ebx
  int *v7; // ebx

  if ( a1 == -1 || !a1 || a2 <= 0 )
    return 0;
  v3 = 0;
  if ( *(_DWORD *)(a1 + 12) <= a2 - 1 )
  {
    v5 = *(_DWORD *)(a1 + 12);
    v4 = v5 / 2;
  }
  else
  {
    v4 = a2 - 1;
    v5 = a2;
  }
  while ( 1 )
  {
    v7 = (int *)(*(_DWORD *)(a1 + 16) + 28 * v4);
    if ( *v7 == a2 )
      break;
    if ( *v7 >= a2 )
    {
      v5 = v4;
      v6 = -1;
    }
    else
    {
      v3 = v4 + 1;
      if ( v5 > a2 - *v7 + v4 + 1 )
        v5 = a2 - *v7 + v4 + 1;
      v6 = 1;
    }
    if ( v3 >= v5 )
      return 0;
    if ( v5 - v3 == 1 )
      v4 += v6;
    else
      v4 += v6 * ((v5 - v3) / 2);
  }
  if ( v7[6] )
    sub_45F0(a1, (_DWORD *)(*(_DWORD *)(a1 + 16) + 28 * v4));
  return v7;
}

//----- (000041B0) --------------------------------------------------------
int *__cdecl sub_41B0(_DWORD *a1, int a2)
{
  int *result; // eax
  int v3; // ebp
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  int v7; // ebx

  if ( !a1 || a1[6] || a2 <= 0 )
    return 0;
  v3 = 0;
  if ( a1[5] <= a2 - 1 )
  {
    v5 = a1[5];
    v4 = v5 / 2;
  }
  else
  {
    v4 = a2 - 1;
    v5 = a2;
  }
  while ( 1 )
  {
    result = (int *)(a1[2] + 12 * v4);
    if ( *result == a2 )
      break;
    if ( *result >= a2 )
    {
      v5 = v4;
      v7 = -1;
    }
    else
    {
      v3 = v4 + 1;
      v6 = a2 - *result + v4 + 1;
      if ( v5 > v6 )
        v5 = v6;
      v7 = 1;
    }
    if ( v3 >= v5 )
      return 0;
    if ( v5 - v3 == 1 )
      v4 += v7;
    else
      v4 += v7 * ((v5 - v3) / 2);
  }
  return result;
}

//----- (00004290) --------------------------------------------------------
int __cdecl sub_4290(int a1, int a2, int a3, int a4)
{
  int *v4; // eax
  int *v5; // edx
  int result; // eax

  v4 = sub_40B0(a1, a2);
  v5 = sub_41B0(v4, a3);
  result = a4;
  if ( v5 )
    return v5[1];
  return result;
}

//----- (000042D0) --------------------------------------------------------
void __cdecl sub_42D0(int a1)
{
  int v1; // esi
  int v2; // ebp
  int v3; // ebx

  if ( a1 != -1 && a1 )
  {
    if ( *(_DWORD *)a1 != 1 )
      sub_56A0(*(void **)(a1 + 4), *(_DWORD *)(a1 + 8));
    v1 = 0;
    if ( *(int *)(a1 + 12) > 0 )
    {
      v2 = 0;
      do
      {
        v3 = *(_DWORD *)(a1 + 16) + v2;
        if ( !*(_DWORD *)(v3 + 24) )
        {
          sub_26E8(*(_DWORD **)(v3 + 12));
          sub_26E8(*(_DWORD **)(v3 + 8));
        }
        v2 += 28;
        ++v1;
      }
      while ( *(_DWORD *)(a1 + 12) > v1 );
    }
    sub_26E8(*(_DWORD **)(a1 + 16));
    sub_26E8((_DWORD *)a1);
  }
}

//----- (000043C0) --------------------------------------------------------
int __usercall sub_43C0@<eax>(off_t a1@<ebp>, char *filename, int a3, int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  int v7; // eax
  size_t v8; // ecx
  int v9; // eax
  unsigned __int8 *v10; // ebx
  int v11; // eax
  unsigned int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // esi
  _DWORD *v16; // ebx
  int v17; // eax
  int v18; // [esp-8h] [ebp-14h]
  mode_t v19; // [esp+0h] [ebp-Ch]

  v4 = (_DWORD *)sub_2378(0x18u);
  v5 = v4;
  if ( !v4 )
    return -1;
  *v4 = a3;
  v7 = sub_5604(filename, 0, v19);
  v5[1] = v7;
  if ( v7 < 0 )
    return 0;
  v18 = v7;
  v9 = *(_DWORD *)(a4 + 20);
  v5[2] = v9;
  v10 = (unsigned __int8 *)sub_5E74(v8, a1, (int)v5, (int)filename, 0, v9, 1, 1, v18, 0);
  if ( v10 == (unsigned __int8 *)-1 )
    return 0;
  sub_5578(v5[1]);
  if ( v5[2] <= 0x1Bu )
    goto LABEL_8;
  v5[1] = v10;
  if ( sub_211C(v10, "*nazgul*", 8) )
    goto LABEL_8;
  v11 = v5[1];
  if ( *(_DWORD *)(v11 + 8) == 1 )
  {
    if ( *(int *)(v11 + 20) > 0 )
    {
      v5[3] = *(_DWORD *)(v11 + 20);
      v12 = 28 * *(_DWORD *)(v5[1] + 20);
      if ( !v12 )
        v12 = 1;
      v13 = sub_2378(v12);
      v5[4] = v13;
      if ( v13 )
      {
        v14 = *(_DWORD *)(v5[1] + 24);
        v15 = 0;
        if ( (int)v5[3] > 0 )
        {
          while ( v5[2] >= v14 )
          {
            v16 = (_DWORD *)(v5[4] + 28 * v15);
            if ( v5[2] < (unsigned int)(v14 + 28) )
              break;
            sub_4760((char *)(v5[1] + v14), (int)v16, 28);
            if ( v16[6] )
            {
              --v15;
            }
            else if ( *v5 == 1 )
            {
              v17 = sub_45F0((int)v5, v16);
              if ( v17 <= 0 )
              {
                if ( v17 == -1 )
                  goto LABEL_16;
                break;
              }
            }
            else
            {
              v16[6] = -1;
            }
            v14 = v16[1];
            if ( v5[3] <= ++v15 )
              goto LABEL_28;
          }
LABEL_8:
          sub_7514(dword_EB78, 17248, "Message Catalog System");
          return 0;
        }
LABEL_28:
        if ( *v5 == 1 )
          sub_56A0((void *)v5[1], v5[2]);
        return (int)v5;
      }
      else
      {
LABEL_16:
        sub_7514(dword_EB78, 17323, "Message Catalog System");
        return -1;
      }
    }
    else
    {
      sub_7514(dword_EB78, 17302, "Message Catalog System", filename, *(_DWORD *)(v11 + 20));
      return 0;
    }
  }
  else
  {
    sub_7514(dword_EB78, 17267, "Message Catalog System", filename, *(_DWORD *)(v11 + 8), 1);
    return 0;
  }
}
// 43F9: variable 'v19' is possibly undefined
// 4420: variable 'v8' is possibly undefined
// EB78: using guessed type _DWORD dword_EB78[20];

//----- (000045F0) --------------------------------------------------------
int __cdecl sub_45F0(int a1, _DWORD *a2)
{
  unsigned int v3; // eax
  int v4; // ebx
  unsigned int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+10h] [ebp-4h]

  v10 = a2[3];
  if ( *(_DWORD *)(a1 + 8) < v10 )
    return 0;
  v3 = a2[4];
  if ( !v3 )
    v3 = 1;
  v4 = sub_2378(v3);
  a2[3] = v4;
  if ( !v4 )
    return -1;
  if ( *(_DWORD *)(a1 + 8) < a2[4] + v10 )
    return 0;
  sub_4760((char *)(*(_DWORD *)(a1 + 4) + v10), v4, a2[4]);
  v11 = a2[2];
  if ( *(_DWORD *)(a1 + 8) < v11 )
    return 0;
  v5 = 12 * a2[5];
  if ( !v5 )
    v5 = 1;
  v6 = sub_2378(v5);
  a2[2] = v6;
  if ( !v6 )
    return -1;
  v7 = 0;
  if ( (int)a2[5] > 0 )
  {
    v8 = 0;
    do
    {
      v9 = a2[2] + v8;
      if ( *(_DWORD *)(a1 + 8) < (unsigned int)(v11 + 12) )
        return 0;
      sub_4760((char *)(v8 + *(_DWORD *)(a1 + 4) + v11), v9, 12);
      if ( *(_DWORD *)(v9 + 8) )
      {
        v8 -= 12;
        --v7;
      }
      else
      {
        *(_DWORD *)(v9 + 4) += a2[3];
      }
      v8 += 12;
    }
    while ( a2[5] > ++v7 );
  }
  a2[6] = 0;
  return 1;
}

//----- (00004734) --------------------------------------------------------
void __usercall sub_4734(_BYTE *a1@<ebp>)
{
  if ( !dword_EBF8 )
  {
    sub_5744(64, (unsigned __int8 *)dword_4724);
    dword_EBF8 = sub_3D60(a1, (_BYTE *)dword_4724 + 1, 0);
  }
}
// 4724: using guessed type int[4];
// EBF8: using guessed type int dword_EBF8;

//----- (00004760) --------------------------------------------------------
void __cdecl sub_4760(char *a1, int a2, int a3)
{
  unsigned int v3; // edx
  char *v4; // edi
  char *v5; // esi
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // eax
  char *v9; // esi
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // edx
  _BYTE *v13; // edi
  char *v14; // esi
  int i; // ecx
  _DWORD *v16; // edi
  char *v17; // esi
  int j; // ecx
  int v19; // eax
  _BYTE *v20; // edi
  char *v21; // esi
  unsigned int k; // ecx

  v3 = a3;
  v4 = (char *)a2;
  v5 = a1;
  if ( a3 > 0 )
  {
    if ( a2 - (int)a1 < (unsigned int)a3 )
    {
      v9 = &a1[a3];
      v10 = (_DWORD *)(a3 + a2);
      if ( a3 > 7 )
      {
        v11 = (unsigned __int8)v10 & 3;
        v12 = a3 - v11;
        v13 = (char *)v10 - 1;
        v14 = v9 - 1;
        for ( i = v11; i; --i )
          *v13-- = *v14--;
        v16 = v13 - 3;
        v17 = v14 - 3;
        for ( j = v12 / 4; j; --j )
        {
          *v16 = *(_DWORD *)v17;
          v17 -= 4;
          --v16;
        }
        v10 = v16 + 1;
        v9 = v17 + 4;
        v19 = v12 + (v12 < 0 ? 3 : 0);
        LOBYTE(v19) = v19 & 0xFC;
        v3 = v12 - v19;
      }
      v20 = (char *)v10 - 1;
      v21 = v9 - 1;
      for ( k = v3; k; --k )
        *v20-- = *v21--;
    }
    else
    {
      if ( a3 > 7 )
      {
        v6 = a3 - (-a2 & 3);
        v7 = -a2 & 3;
        qmemcpy((void *)a2, a1, v7);
        qmemcpy((void *)(a2 + v7), &a1[v7], 4 * (v6 / 4));
        v5 = &a1[4 * (v6 / 4) + v7];
        v4 = (char *)(a2 + v7 + 4 * (v6 / 4));
        v8 = v6 + (v6 < 0 ? 3 : 0);
        LOBYTE(v8) = v8 & 0xFC;
        v3 = v6 - v8;
      }
      qmemcpy(v4, v5, v3);
    }
  }
}

//----- (00005524) --------------------------------------------------------
int __cdecl sub_5524(int a1)
{
  int result; // eax

  result = sub_8B18(a1);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (00005554) --------------------------------------------------------
char *__cdecl sub_5554(char *a1, char a2)
{
  char v3; // al

  while ( 1 )
  {
    v3 = *a1++;
    if ( v3 == a2 )
      break;
    if ( !v3 )
    {
      a1 = (_BYTE *)(start + 1);
      return a1 - 1;
    }
  }
  return a1 - 1;
}
// 0: using guessed type void __cdecl __noreturn start(int, int);

//----- (00005578) --------------------------------------------------------
int __cdecl sub_5578(int fd)
{
  int result; // eax

  result = sys_close(fd);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00005598) --------------------------------------------------------
int sub_5598()
{
  __asm { int     80h; LINUX - sys_getpid }
  return 20;
}
// E924: using guessed type int dword_E924;

//----- (000055B8) --------------------------------------------------------
int __cdecl sub_55B8(int d, int request)
{
  int result; // eax

  result = sys_ioctl(d, request);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (000055E0) --------------------------------------------------------
int __cdecl sub_55E0(pid_t pid, int sig)
{
  int result; // eax

  result = sys_kill(pid, sig);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00005604) --------------------------------------------------------
int __cdecl sub_5604(char *filename, int flags, mode_t mode)
{
  int result; // eax

  result = sys_open(filename, flags, mode);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (0000562C) --------------------------------------------------------
int __cdecl sub_562C(int fd, void *addr, size_t len)
{
  int result; // eax

  result = sys_read(fd, addr, len);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00005654) --------------------------------------------------------
int __cdecl sub_5654(const char *path, struct stat *buf)
{
  int result; // eax

  result = sys_newstat(path, buf);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00005678) --------------------------------------------------------
int __cdecl sub_5678(int fd, const void *addr, size_t len)
{
  int result; // eax

  result = sys_write(fd, addr, len);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (000056A0) --------------------------------------------------------
int __cdecl sub_56A0(void *addr, int len)
{
  int result; // eax

  result = sys_munmap(addr, len);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00005744) --------------------------------------------------------
char *__cdecl sub_5744(int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // ebx
  _DWORD *v4; // ebp
  unsigned __int8 *v5; // eax
  int v6; // [esp+10h] [ebp-4h]

  v2 = a2;
  if ( (a1 & 0xFFFFFF80) != 0 )
    return 0;
  if ( !a2 )
    return off_EC40;
  v4 = (_DWORD *)&unk_EC00;
  v6 = 0;
  do
  {
    if ( (a1 & *v4) == 0 )
      goto LABEL_19;
    if ( !*v2 )
    {
      v5 = sub_2E94(*(char **)(v6 + 60420));
      if ( v5 )
      {
        v2 = v5;
      }
      else
      {
        if ( a1 == 127 )
          goto LABEL_19;
        v2 = sub_2E94("LANG");
        if ( !v2 )
        {
          v2 = sub_2E94("LC_default");
          if ( !v2 )
            v2 = "C";
        }
      }
    }
    if ( memcmp(v2, sub_5728, 6u) && sub_8C40(v2, (unsigned __int8 *)off_EC40) )
    {
      if ( memcmp(v2, "C", 2u) && memcmp(v2, (char *)&loc_572D + 1, 0xBu) )
      {
        dword_E924 = 22;
        return 0;
      }
      off_EC40 = (char *)v2;
      if ( (*v4 & a1) == 2 )
        JUMPOUT(0x587D);
    }
LABEL_19:
    v4 += 2;
    v6 += 8;
  }
  while ( (unsigned int)v4 <= 0xEC30 );
  if ( a1 == 127 )
    return off_EC40;
  else
    return (char *)v2;
}
// 5876: control flows out of bounds to 587D
// 5728: using guessed type int sub_5728();
// E924: using guessed type int dword_E924;
// EAC8: using guessed type __int16 *off_EAC8;
// EAD0: using guessed type int (*off_EAD0)[67];
// EC40: using guessed type char *off_EC40;

//----- (00005E74) --------------------------------------------------------
int __usercall sub_5E74@<eax>(
        size_t a1@<ecx>,
        off_t a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10)
{
  int v10; // edx
  _DWORD start[6]; // [esp+8h] [ebp-18h] BYREF

  start[0] = a5;
  start[1] = a6;
  start[2] = a7;
  start[3] = a8;
  start[4] = a9;
  start[5] = a10;
  v10 = old_mmap(start, a1, (int)start, a4, a3, a2);
  if ( (unsigned int)(v10 + 4096) <= 0xFFF )
  {
    dword_E924 = -v10;
    return -1;
  }
  return v10;
}
// E924: using guessed type int dword_E924;

//----- (00005ED8) --------------------------------------------------------
int __cdecl sub_5ED8(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 68) = 0;
  result = sub_6950(a1);
  *(_DWORD *)(a1 + 60) = -1;
  return result;
}

//----- (00005EF8) --------------------------------------------------------
int __cdecl sub_5EF8(int a1)
{
  int v2; // ebx

  if ( *(int *)(a1 + 60) < 0
    || (*(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 20) || (*(_BYTE *)(a1 + 1) & 8) != 0) && sub_6A00(a1) )
  {
    return -1;
  }
  sub_7390(a1);
  v2 = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 44))(a1);
  sub_6CE0(a1, 0, 0, 0);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  sub_6900((char *)a1);
  *(_DWORD *)a1 = -72539124;
  *(_DWORD *)(a1 + 60) = -1;
  *(_DWORD *)(a1 + 68) = 0;
  return v2;
}

//----- (00005FA8) --------------------------------------------------------
void __cdecl sub_5FA8(_BYTE *a1)
{
  if ( (*a1 & 0x40) == 0 )
    sub_5EF8((int)a1);
  sub_70A0((int)a1);
}

//----- (00005FC8) --------------------------------------------------------
unsigned int *__cdecl sub_5FC8(unsigned int *a1, char *filename, char *a3)
{
  int v3; // ecx
  char v4; // al
  _BYTE *v5; // edx
  int v6; // eax
  int v7; // ebx
  int v9; // eax
  unsigned int v10; // eax

  v3 = 0;
  if ( (a1[15] & 0x80000000) == 0 )
    return 0;
  v4 = *a3;
  v5 = a3 + 1;
  if ( *a3 == 114 )
  {
    v6 = 0;
    v7 = 8;
  }
  else if ( v4 > 114 )
  {
    if ( v4 != 119 )
      goto LABEL_11;
    v6 = 1;
    v3 = 576;
    v7 = 4;
  }
  else
  {
    if ( v4 != 97 )
    {
LABEL_11:
      dword_E924 = 22;
      return 0;
    }
    v6 = 1;
    v3 = 1088;
    v7 = 4100;
  }
  if ( *v5 == 43 || *v5 == 98 && a3[2] == 43 )
  {
    v6 = 2;
    v7 &= 0x1000u;
  }
  v9 = sub_5604(filename, v3 | v6, 0x1B6u);
  if ( v9 < 0 )
    return 0;
  a1[15] = v9;
  *a1 |= 0x240Cu;
  v10 = v7 | *a1 & 0xFFFFEFF3;
  *a1 = v10;
  *a1 = v10;
  if ( (v7 & 0x1000) != 0
    && (*(int (__cdecl **)(unsigned int *, _DWORD, int))(a1[14] + 56))(a1, 0, 2) == -1
    && dword_E924 != 29 )
  {
    return 0;
  }
  sub_6950((int)a1);
  return a1;
}
// E924: using guessed type int dword_E924;

//----- (000060E8) --------------------------------------------------------
_DWORD *__cdecl sub_60E8(_DWORD *a1, int a2)
{
  _BYTE v3[8]; // [esp+4h] [ebp-40h] BYREF
  __int16 v4; // [esp+Ch] [ebp-38h]

  if ( (int)a1[15] >= 0 )
    return 0;
  a1[15] = a2;
  *a1 &= 0xFFFFFFF3;
  if ( !(*(int (__cdecl **)(_DWORD *, _BYTE *))(a1[14] + 48))(a1, v3)
    && (v4 & 0xF000) == 0x8000
    && (a1[17] = -1, (*(int (__cdecl **)(_DWORD *, _DWORD, int))(a1[14] + 56))(a1, 0, 1) == -1)
    && dword_E924 != 29 )
  {
    return 0;
  }
  else
  {
    return a1;
  }
}
// E924: using guessed type int dword_E924;

//----- (00006168) --------------------------------------------------------
int __cdecl sub_6168(_DWORD *a1, int a2, int a3)
{
  int v3; // eax

  if ( sub_6F10(a1, a2, a3) == -1 )
    return -1;
  v3 = a1[7];
  a1[6] = v3;
  a1[5] = v3;
  a1[4] = v3;
  a1[3] = a1[7];
  a1[1] = a1[7];
  a1[2] = a1[7];
  return 0;
}

//----- (000061B8) --------------------------------------------------------
int __cdecl sub_61B8(int a1, unsigned int a2, int a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax

  if ( !a3 )
    return 0;
  if ( (*(_BYTE *)(a1 + 1) & 0x10) != 0 )
  {
    *(_DWORD *)(a1 + 68) = -1;
  }
  else if ( *(_DWORD *)(a1 + 16) != *(_DWORD *)(a1 + 8) )
  {
    v4 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 56) + 52))(
           a1,
           *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 8),
           1);
    if ( v4 == -1 )
      return -1;
    *(_DWORD *)(a1 + 68) = v4;
  }
  v5 = (*(int (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(a1 + 56) + 20))(a1, a2, a3);
  if ( *(_WORD *)(a1 + 72) )
    *(_WORD *)(a1 + 72) = sub_7180(*(unsigned __int16 *)(a1 + 72) - 1, a2, a3) + 1;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 28);
  v6 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 20) = v6;
  *(_DWORD *)(a1 + 16) = v6;
  if ( (*(_WORD *)a1 & 0x202) != 0 )
    v7 = *(_DWORD *)(a1 + 28);
  else
    v7 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 24) = v7;
  return -(v5 != a3);
}

//----- (00006298) --------------------------------------------------------
int __cdecl sub_6298(int a1)
{
  unsigned __int8 *v2; // eax
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax

  if ( (*(_BYTE *)a1 & 4) != 0 )
    return -1;
  v2 = *(unsigned __int8 **)(a1 + 4);
  if ( *(_DWORD *)(a1 + 8) > (unsigned int)v2 )
    return *v2;
  if ( !*(_DWORD *)(a1 + 28) )
    sub_6D30(a1);
  if ( (*(_WORD *)a1 & 0x202) != 0 )
    sub_7230();
  sub_6A00(a1);
  v3 = (*(int (__cdecl **)(int, _DWORD, int))(*(_DWORD *)(a1 + 56) + 16))(
         a1,
         *(_DWORD *)(a1 + 28),
         *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
  v4 = v3;
  if ( v3 <= 0 )
  {
    if ( v3 && dword_E924 != 11 )
      *(_BYTE *)a1 |= 0x20u;
    else
      *(_BYTE *)a1 |= 0x10u;
    v4 = 0;
  }
  v5 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 4) = v5;
  *(_DWORD *)(a1 + 12) = v5;
  *(_DWORD *)(a1 + 8) = v4 + *(_DWORD *)(a1 + 28);
  v6 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 24) = v6;
  *(_DWORD *)(a1 + 20) = v6;
  *(_DWORD *)(a1 + 16) = v6;
  if ( !v4 )
    return -1;
  if ( *(_DWORD *)(a1 + 68) != -1 )
    *(_DWORD *)(a1 + 68) += v4;
  return **(unsigned __int8 **)(a1 + 4);
}
// E924: using guessed type int dword_E924;

//----- (00006358) --------------------------------------------------------
int __cdecl sub_6358(int a1, int a2)
{
  int v3; // eax
  int v4; // eax

  if ( (*(_BYTE *)a1 & 8) != 0 )
    return -1;
  if ( (*(_BYTE *)(a1 + 1) & 8) == 0 )
  {
    if ( *(_DWORD *)(a1 + 28) )
    {
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 4);
    }
    else
    {
      sub_6D30(a1);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 28);
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
    v3 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 4) = v3;
    *(_DWORD *)(a1 + 12) = v3;
    if ( (*(_WORD *)a1 & 0x202) != 0 )
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)a1 |= 0x800u;
  }
  if ( a2 == -1 )
    return sub_61B8(a1, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
  v4 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 32) == v4 && sub_61B8(a1, *(_DWORD *)(a1 + 16), v4 - *(_DWORD *)(a1 + 16)) == -1 )
    return -1;
  *(_BYTE *)(*(_DWORD *)(a1 + 20))++ = a2;
  if ( ((*(_BYTE *)a1 & 2) != 0 || (*(_BYTE *)(a1 + 1) & 2) != 0 && a2 == 10)
    && sub_61B8(a1, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16)) == -1 )
  {
    return -1;
  }
  return (unsigned __int8)a2;
}

//----- (00006468) --------------------------------------------------------
int __cdecl sub_6468(_DWORD *a1)
{
  unsigned int v1; // eax
  int v3; // edx
  int v4; // eax

  v1 = a1[5];
  if ( a1[4] < v1 && sub_61B8((int)a1, a1[4], v1 - a1[4]) )
    return -1;
  v3 = a1[1] - a1[2];
  if ( v3 )
  {
    v4 = (*(int (__cdecl **)(_DWORD *, int, int))(a1[14] + 52))(a1, v3, 1);
    if ( v4 == -1 )
      return -1;
    a1[17] = v4;
    a1[2] = a1[1];
  }
  return 0;
}

//----- (000064C8) --------------------------------------------------------
int __cdecl sub_64C8(int a1, int a2, char a3)
{
  int v4; // edi
  int v6; // eax
  int v7; // eax
  int v8; // ebp
  int v9; // edi
  int v10; // ebp
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ebp
  int v16; // eax
  _BYTE v17[8]; // [esp+10h] [ebp-40h] BYREF
  __int16 v18; // [esp+18h] [ebp-38h]
  int v19; // [esp+24h] [ebp-2Ch]

  v4 = a3 & 3;
  if ( (a3 & 4) != 0 && (a3 & 8) != 0 )
  {
    v4 = 1;
    a2 = 0;
  }
  if ( (*(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 20) || (*(_BYTE *)(a1 + 1) & 8) != 0) && sub_6A00(a1) )
    return -1;
  if ( !*(_DWORD *)(a1 + 28) )
  {
    sub_6D30(a1);
    v6 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 20) = v6;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 28);
  }
  if ( v4 == 1 )
  {
    if ( *(_DWORD *)(a1 + 68) == -1 )
      goto LABEL_28;
    a2 = *(_DWORD *)(a1 + 68) + a2 - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4));
  }
  else if ( v4 == 2 )
  {
    if ( (*(int (__cdecl **)(int, _BYTE *))(*(_DWORD *)(a1 + 56) + 48))(a1, v17) || (v18 & 0xF000) != 0x8000 )
      goto LABEL_28;
    a2 += v19;
  }
  v7 = *(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 32);
  v8 = v7 & a2;
  v9 = a2 - (v7 & a2);
  if ( v9 > *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28) )
  {
    v8 = a2;
    v9 = 0;
  }
  v10 = (*(int (__cdecl **)(int, int, _DWORD))(*(_DWORD *)(a1 + 56) + 52))(a1, v8, 0);
  if ( v10 < 0 )
    return -1;
  if ( !v9 )
  {
    v11 = 0;
LABEL_27:
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 28) + v9;
    *(_DWORD *)(a1 + 8) = v11 + *(_DWORD *)(a1 + 28);
    v13 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 20) = v13;
    *(_DWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 68) = v11 + v10;
    *(_DWORD *)a1 &= ~0x10u;
    return a2;
  }
  v12 = (*(int (__cdecl **)(int, _DWORD, int))(*(_DWORD *)(a1 + 56) + 16))(
          a1,
          *(_DWORD *)(a1 + 28),
          *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
  v11 = v12;
  if ( v12 >= v9 )
    goto LABEL_27;
  a2 = v9;
  if ( v12 != -1 )
    a2 = v9 - v12;
  v4 = 1;
LABEL_28:
  sub_7390(a1);
  v14 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 56) + 52))(a1, a2, v4);
  v15 = v14;
  if ( v14 != -1 )
    *(_DWORD *)a1 &= ~0x10u;
  *(_DWORD *)(a1 + 68) = v14;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 28);
  v16 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 20) = v16;
  *(_DWORD *)(a1 + 16) = v16;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 28);
  return v15;
}

//----- (000066A8) --------------------------------------------------------
int __cdecl sub_66A8(int a1, void *addr, size_t len)
{
  int result; // eax

  do
    result = sub_562C(*(_DWORD *)(a1 + 60), addr, len);
  while ( dword_E924 == 4 && result == -1 );
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00006738) --------------------------------------------------------
int __cdecl sub_6738(int a1, char *addr, size_t len)
{
  signed int v4; // ebx
  int v5; // eax

  v4 = len;
  while ( v4 > 0 )
  {
    v5 = sub_5678(*(_DWORD *)(a1 + 60), addr, v4);
    if ( v5 == -1 )
    {
      if ( dword_E924 != 4 )
      {
        *(_BYTE *)a1 |= 0x20u;
        break;
      }
    }
    else
    {
      v4 -= v5;
      addr += v5;
    }
  }
  if ( *(int *)(a1 + 68) >= 0 )
    *(_DWORD *)(a1 + 68) += len - v4;
  return len - v4;
}
// E924: using guessed type int dword_E924;

//----- (00006798) --------------------------------------------------------
unsigned int __cdecl sub_6798(_DWORD *a1, char *a2, unsigned int a3)
{
  char *v3; // esi
  unsigned int v4; // edi
  int v5; // ebp
  signed int v7; // ebx
  char *v8; // ecx
  int i; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ebp
  unsigned int v12; // ebx
  _BYTE *v13; // [esp+10h] [ebp-8h]

  v3 = a2;
  v4 = a3;
  v5 = 0;
  if ( !a3 )
    return 0;
  v7 = a1[6] - a1[5];
  if ( (*a1 & 0xA00) == 0xA00 )
  {
    v7 = a1[8] - a1[5];
    if ( a3 <= v7 )
    {
      v8 = &a2[a3];
      if ( &a2[a3] > a2 )
      {
        while ( *--v8 != 10 )
        {
          if ( v8 <= a2 )
            goto LABEL_9;
        }
        v7 = v8 - a2 + 1;
        v5 = 1;
      }
    }
  }
LABEL_9:
  if ( v7 > 0 )
  {
    if ( v7 > a3 )
      v7 = a3;
    if ( v7 <= 20 )
    {
      v13 = (_BYTE *)a1[5];
      for ( i = v7 - 1; i >= 0; --i )
        *v13++ = *v3++;
    }
    else
    {
      sub_1FC4(a1[5], a2, v7);
      v3 = &a2[v7];
    }
    a1[5] += v7;
    v4 = a3 - v7;
  }
  if ( v5 + v4 )
  {
    if ( sub_6AB0((int)a1, -1) == -1 )
      return a3 - v4;
    v10 = a1[8] - a1[7];
    v11 = v10 <= 0x7F ? 0 : v4 % v10;
    v12 = v4 - v11;
    if ( sub_61B8((int)a1, (unsigned int)v3, v4 - v11) == -1 )
      return a3 - v4;
    v4 = v11;
    if ( v11 )
      v4 = v11 - sub_6D80((int)a1, &v3[v12], v11);
  }
  return a3 - v4;
}

//----- (00006900) --------------------------------------------------------
void __cdecl sub_6900(char *a1)
{
  _DWORD *v1; // eax

  if ( *a1 < 0 )
  {
    v1 = &off_EBC8;
    if ( off_EBC8 )
    {
      while ( (char *)*v1 != a1 )
      {
        v1 = (_DWORD *)(*v1 + 52);
        if ( !*v1 )
          goto LABEL_6;
      }
      *v1 = *((_DWORD *)a1 + 13);
    }
LABEL_6:
    *(_DWORD *)a1 &= ~0x80u;
  }
}
// EBC8: using guessed type _UNKNOWN *off_EBC8;

//----- (00006950) --------------------------------------------------------
int __cdecl sub_6950(int a1)
{
  int result; // eax

  result = a1;
  if ( *(char *)a1 >= 0 )
  {
    *(_BYTE *)a1 |= 0x80u;
    *(_DWORD *)(a1 + 52) = off_EBC8;
    off_EBC8 = (_UNKNOWN *)a1;
  }
  return result;
}
// EBC8: using guessed type _UNKNOWN *off_EBC8;

//----- (00006970) --------------------------------------------------------
int __cdecl sub_6970(_DWORD *a1)
{
  int v1; // edx
  _DWORD *i; // eax

  v1 = a1[2] - a1[3];
  for ( i = (_DWORD *)a1[12]; i; i = (_DWORD *)*i )
  {
    if ( i[2] < v1 )
      v1 = i[2];
  }
  return v1;
}

//----- (000069A0) --------------------------------------------------------
_DWORD *__cdecl sub_69A0(_DWORD *a1)
{
  int v2; // edx
  int v3; // edx

  *a1 &= ~0x100u;
  v2 = a1[2];
  a1[2] = a1[11];
  a1[11] = v2;
  v3 = a1[3];
  a1[3] = a1[9];
  a1[9] = v3;
  a1[1] = a1[3];
  return a1;
}

//----- (000069D0) --------------------------------------------------------
_DWORD *__cdecl sub_69D0(_DWORD *a1)
{
  int v2; // edx
  int v3; // edx

  *a1 |= 0x100u;
  v2 = a1[2];
  a1[2] = a1[11];
  a1[11] = v2;
  v3 = a1[3];
  a1[3] = a1[9];
  a1[9] = v3;
  a1[1] = a1[2];
  return a1;
}

//----- (00006A00) --------------------------------------------------------
int __cdecl sub_6A00(int a1)
{
  unsigned int v2; // eax
  int v3; // eax

  if ( *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 20) && (**(int (__cdecl ***)(int, int))(a1 + 56))(a1, -1) == -1 )
    return -1;
  if ( (*(_BYTE *)(a1 + 1) & 1) != 0 )
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 40);
  }
  else
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 28);
    v2 = *(_DWORD *)(a1 + 20);
    if ( *(_DWORD *)(a1 + 8) < v2 )
      *(_DWORD *)(a1 + 8) = v2;
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 20);
  v3 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 24) = v3;
  *(_DWORD *)(a1 + 20) = v3;
  *(_DWORD *)(a1 + 16) = v3;
  *(_DWORD *)a1 &= ~0x800u;
  return 0;
}

//----- (00006A70) --------------------------------------------------------
void __cdecl sub_6A70(int a1)
{
  if ( (*(_BYTE *)(a1 + 1) & 1) != 0 )
    sub_69A0((_DWORD *)a1);
  sub_26E8(*(_DWORD **)(a1 + 36));
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 40) = 0;
}

//----- (00006AB0) --------------------------------------------------------
int __cdecl sub_6AB0(int a1, int a2)
{
  return (**(int (__cdecl ***)(int, int))(a1 + 56))(a1, a2);
}

//----- (00006AD0) --------------------------------------------------------
int __cdecl sub_6AD0(int a1)
{
  unsigned __int8 *v2; // eax
  char *v3; // eax
  int v4; // edi
  signed int v5; // ebp
  int v6; // eax
  unsigned int v7; // eax
  int v8; // edx
  _DWORD *i; // eax
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]

  if ( (*(_BYTE *)(a1 + 1) & 8) != 0 && sub_6A00(a1) == -1 )
    return -1;
  v2 = *(unsigned __int8 **)(a1 + 4);
  if ( *(_DWORD *)(a1 + 8) > (unsigned int)v2 )
    return *v2;
  if ( (*(_BYTE *)(a1 + 1) & 1) != 0 )
  {
    sub_69A0((_DWORD *)a1);
    v3 = *(char **)(a1 + 4);
    if ( *(_DWORD *)(a1 + 8) > (unsigned int)v3 )
      return *v3;
  }
  if ( *(_DWORD *)(a1 + 48) )
  {
    v4 = sub_6970((_DWORD *)a1);
    v5 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12) - v4;
    v6 = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 36);
    if ( v5 <= v6 )
    {
      v11 = v6 - v5;
      if ( v4 >= 0 )
      {
        if ( v5 > 0 )
          sub_1FC4(*(_DWORD *)(a1 + 36) + v11, (char *)(*(_DWORD *)(a1 + 12) + v4), v5);
      }
      else
      {
        sub_8B50(*(_DWORD *)(a1 + 36) + v11, (char *)(*(_DWORD *)(a1 + 44) + v4), -v4);
        sub_1FC4(*(_DWORD *)(a1 + 36) + v11 - v4, *(char **)(a1 + 12), *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12));
      }
    }
    else
    {
      v11 = 100;
      v7 = v5 + 100;
      if ( v5 == -100 )
        v7 = 1;
      v10 = sub_2378(v7);
      if ( !v10 )
        return -1;
      if ( v4 >= 0 )
      {
        sub_1FC4(v10 + 100, (char *)(*(_DWORD *)(a1 + 12) + v4), v5);
      }
      else
      {
        sub_1FC4(v10 + 100, (char *)(*(_DWORD *)(a1 + 44) + v4), -v4);
        sub_1FC4(v10 + 100 - v4, *(char **)(a1 + 12), *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12));
      }
      sub_26E8(*(_DWORD **)(a1 + 36));
      *(_DWORD *)(a1 + 36) = v10;
      *(_DWORD *)(a1 + 44) = v5 + v10 + 100;
    }
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 36) + v11;
    v8 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12);
    for ( i = *(_DWORD **)(a1 + 48); i; i = (_DWORD *)*i )
      i[2] -= v8;
  }
  else if ( *(_DWORD *)(a1 + 36) )
  {
    sub_6A70(a1);
  }
  return (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 4))(a1);
}

//----- (00006CE0) --------------------------------------------------------
int __cdecl sub_6CE0(int a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 28) && (*(_BYTE *)a1 & 1) == 0 )
    sub_26E8(*(_DWORD **)(a1 + 28));
  *(_DWORD *)(a1 + 28) = a2;
  result = a3;
  *(_DWORD *)(a1 + 32) = a3;
  if ( a4 )
    *(_DWORD *)a1 &= ~1u;
  else
    *(_BYTE *)a1 |= 1u;
  return result;
}

//----- (00006D30) --------------------------------------------------------
void __cdecl sub_6D30(int a1)
{
  if ( !*(_DWORD *)(a1 + 28)
    && ((*(_BYTE *)a1 & 2) != 0 || (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 24))(a1) == -1) )
  {
    sub_6CE0(a1, a1 + 75, a1 + 76, 0);
  }
}

//----- (00006D70) --------------------------------------------------------
int sub_6D70()
{
  return -1;
}

//----- (00006D80) --------------------------------------------------------
unsigned int __cdecl sub_6D80(int a1, char *a2, unsigned int a3)
{
  unsigned int v4; // edi
  signed int v6; // ebx
  _BYTE *v7; // edx
  int i; // eax
  int v9; // [esp-4h] [ebp-14h]

  v4 = a3;
  if ( !a3 )
    return 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20);
    if ( v6 > 0 )
    {
      if ( v6 > v4 )
        v6 = v4;
      if ( v6 <= 20 )
      {
        if ( v6 > 0 )
        {
          v7 = *(_BYTE **)(a1 + 20);
          for ( i = v6 - 1; i >= 0; --i )
            *v7++ = *a2++;
          *(_DWORD *)(a1 + 20) = v7;
        }
        else
        {
          v6 = 0;
        }
      }
      else
      {
        sub_1FC4(*(_DWORD *)(a1 + 20), a2, v6);
        a2 += v6;
        *(_DWORD *)(a1 + 20) += v6;
      }
      v4 -= v6;
    }
    if ( !v4 )
      break;
    v9 = (unsigned __int8)*a2++;
    if ( sub_6AB0(a1, v9) == -1 )
      break;
    --v4;
  }
  return a3 - v4;
}

//----- (00006E50) --------------------------------------------------------
unsigned int __cdecl sub_6E50(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // edi
  signed int v5; // ebx
  _BYTE *v6; // edx
  int i; // eax

  v3 = a3;
  do
  {
    v5 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
    if ( v5 > 0 )
    {
      if ( v5 > v3 )
        v5 = v3;
      if ( v5 <= 20 )
      {
        if ( v5 > 0 )
        {
          v6 = *(_BYTE **)(a1 + 4);
          for ( i = v5 - 1; i >= 0; --i )
            *a2++ = *v6++;
          *(_DWORD *)(a1 + 4) = v6;
        }
        else
        {
          v5 = 0;
        }
      }
      else
      {
        sub_1FC4((int)a2, *(char **)(a1 + 4), v5);
        a2 += v5;
        *(_DWORD *)(a1 + 4) += v5;
      }
      v3 -= v5;
    }
  }
  while ( v3 && sub_6AD0(a1) != -1 );
  return a3 - v3;
}

//----- (00006F10) --------------------------------------------------------
int __cdecl sub_6F10(_DWORD *a1, int a2, int a3)
{
  if ( (*(int (__cdecl **)(_DWORD *))(a1[14] + 36))(a1) == -1 )
    return -1;
  if ( a2 && a3 )
  {
    *a1 &= ~2u;
    sub_6CE0((int)a1, a2, a3 + a2, 0);
  }
  else
  {
    *(_BYTE *)a1 |= 2u;
    sub_6CE0((int)a1, (int)a1 + 75, (int)(a1 + 19), 0);
  }
  a1[6] = 0;
  a1[5] = 0;
  a1[4] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[3] = 0;
  return 0;
}

//----- (00007010) --------------------------------------------------------
int __cdecl sub_7010(int a1, int a2)
{
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 72) = 0;
  return a1;
}

//----- (00007090) --------------------------------------------------------
int sub_7090()
{
  return 0;
}

//----- (000070A0) --------------------------------------------------------
void __cdecl sub_70A0(int a1)
{
  _DWORD *i; // eax

  if ( *(_DWORD *)(a1 + 28) && (*(_BYTE *)a1 & 1) == 0 )
    sub_26E8(*(_DWORD **)(a1 + 28));
  for ( i = *(_DWORD **)(a1 + 48); i; i = (_DWORD *)*i )
    i[1] = 0;
  sub_26E8(*(_DWORD **)(a1 + 36));
  sub_6900((char *)a1);
}

//----- (000070F0) --------------------------------------------------------
int sub_70F0()
{
  return -1;
}

//----- (00007100) --------------------------------------------------------
int __cdecl sub_7100(_DWORD *a1, int a2)
{
  unsigned int v2; // eax

  v2 = a1[1];
  if ( a1[3] >= v2 || *(_BYTE *)(v2 - 1) != (_BYTE)a2 )
    return (*(int (__cdecl **)(_DWORD *, int))(a1[14] + 28))(a1, a2);
  --a1[1];
  return (unsigned __int8)a2;
}

//----- (00007160) --------------------------------------------------------
int __cdecl sub_7160(int a1, __int16 a2)
{
  *(_WORD *)(a1 + 72) = a2 + 1;
  return 0;
}

//----- (00007180) --------------------------------------------------------
int __cdecl sub_7180(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // edx

  v3 = a3 + a2;
  if ( a3 + a2 <= a2 )
    return a3 + a1;
  while ( *(_BYTE *)--v3 != 10 )
  {
    if ( v3 <= a2 )
      return a3 + a1;
  }
  return a3 + a2 - v3 - 1;
}

//----- (000071F0) --------------------------------------------------------
int sub_71F0()
{
  int v0; // esi
  _DWORD *v1; // ebx

  v0 = 0;
  v1 = off_EBC8;
  if ( off_EBC8 )
  {
    do
    {
      if ( (*(int (__cdecl **)(_DWORD *, int))v1[14])(v1, -1) == -1 )
        v0 = -1;
      v1 = (_DWORD *)v1[13];
    }
    while ( v1 );
  }
  return v0;
}
// EBC8: using guessed type _UNKNOWN *off_EBC8;

//----- (00007230) --------------------------------------------------------
int sub_7230()
{
  _DWORD *v0; // ebx
  int result; // eax

  v0 = off_EBC8;
  if ( off_EBC8 )
  {
    do
    {
      if ( (*((_BYTE *)v0 + 1) & 2) != 0 )
        result = (*(int (__cdecl **)(_DWORD *, int))v0[14])(v0, -1);
      v0 = (_DWORD *)v0[13];
    }
    while ( v0 );
  }
  return result;
}
// EBC8: using guessed type _UNKNOWN *off_EBC8;

//----- (00007260) --------------------------------------------------------
int __cdecl sub_7260(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx

  a1[1] = a2;
  if ( (*(_BYTE *)(a2 + 1) & 8) != 0 )
    result = sub_6A00(a2);
  if ( (*(_BYTE *)(a2 + 1) & 1) != 0 )
    v3 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 8);
  else
    v3 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 12);
  a1[2] = v3;
  *a1 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 48) = a1;
  return result;
}

//----- (000072E0) --------------------------------------------------------
int __cdecl sub_72E0(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);
}

//----- (00007330) --------------------------------------------------------
int __cdecl sub_7330(int a1, int a2)
{
  int v3; // edx

  if ( *(_DWORD *)(a2 + 4) != a1 )
    return -1;
  if ( *(int *)(a2 + 8) < 0 )
  {
    if ( (*(_BYTE *)(a1 + 1) & 1) == 0 )
      sub_69D0((_DWORD *)a1);
    v3 = *(_DWORD *)(a1 + 8);
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 1) & 1) != 0 )
      sub_69A0((_DWORD *)a1);
    v3 = *(_DWORD *)(a1 + 12);
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 8) + v3;
  return 0;
}

//----- (00007390) --------------------------------------------------------
void __cdecl sub_7390(int a1)
{
  if ( *(_DWORD *)(a1 + 48) )
    *(_DWORD *)(a1 + 48) = 0;
  sub_6A70(a1);
}

//----- (000073E0) --------------------------------------------------------
int __cdecl sub_73E0(int a1, int a2)
{
  int v2; // eax
  int v4; // eax
  unsigned int v5; // ebp
  unsigned int v6; // eax
  int v7; // eax
  int v8; // edi
  unsigned int v9; // ebx
  _BYTE *v10; // edx

  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 4) )
  {
    if ( !*(_DWORD *)(a1 + 36) )
      goto LABEL_6;
    if ( (*(_BYTE *)(a1 + 1) & 1) == 0 )
      sub_69D0((_DWORD *)a1);
    if ( *(_DWORD *)(a1 + 36) )
    {
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 4) )
      {
        v5 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12);
        v6 = 2 * v5;
        if ( !(2 * v5) )
          v6 = 1;
        v7 = sub_2378(v6);
        v8 = v7;
        if ( !v7 )
          return -1;
        v9 = v7 + v5;
        sub_1FC4(v7 + v5, *(char **)(a1 + 12), v5);
        sub_26E8(*(_DWORD **)(a1 + 12));
        *(_DWORD *)(a1 + 12) = v8;
        *(_DWORD *)(a1 + 4) = v9;
        *(_DWORD *)(a1 + 8) = 2 * v5 + v8;
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 4);
      }
    }
    else
    {
LABEL_6:
      v2 = sub_2378(0x80u);
      if ( !v2 )
        return -1;
      *(_DWORD *)(a1 + 36) = v2;
      v4 = v2 + 128;
      *(_DWORD *)(a1 + 44) = v4;
      *(_DWORD *)(a1 + 40) = v4;
      sub_69D0((_DWORD *)a1);
    }
  }
  --*(_DWORD *)(a1 + 4);
  if ( a2 != -1 )
  {
    v10 = *(_BYTE **)(a1 + 4);
    if ( a2 != (char)*v10 )
      *v10 = a2;
  }
  return **(unsigned __int8 **)(a1 + 4);
}

//----- (000074E0) --------------------------------------------------------
int sub_74E0()
{
  return -1;
}

//----- (000074F0) --------------------------------------------------------
int sub_74F0()
{
  return -1;
}

//----- (00007500) --------------------------------------------------------
int sub_7500()
{
  return -1;
}

//----- (00007510) --------------------------------------------------------
int sub_7510()
{
  return 0;
}

//----- (00007514) --------------------------------------------------------
int sub_7514(_DWORD *a1, int a2, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  if ( a1 && (*a1 & 0xFFFF0000) == 0xFBAD0000 )
    return sub_775C(a1, a2, (int)va);
  dword_E924 = 5;
  return -1;
}
// E924: using guessed type int dword_E924;

//----- (00007564) --------------------------------------------------------
int __cdecl sub_7564(const char *a1, _DWORD *a2)
{
  unsigned int v2; // kr04_4

  v2 = strlen(a1) + 1;
  if ( a2 && (*a2 & 0xFFFF0000) == 0xFBAD0000 )
  {
    if ( (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(a2[14] + 8))(a2, a1, v2 - 1) == v2 - 1 )
      return 1;
    else
      return -1;
  }
  else
  {
    dword_E924 = 5;
    return -1;
  }
}
// E924: using guessed type int dword_E924;

//----- (000075DC) --------------------------------------------------------
int sub_75DC(const char *a1, int a2, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  return sub_806C(a1, a2, (int)va);
}

//----- (000075F4) --------------------------------------------------------
int sub_75F4(const char *a1, unsigned __int8 *a2, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  return sub_80E0(a1, a2, (int)va);
}

//----- (0000760C) --------------------------------------------------------
int __cdecl sub_760C(_DWORD *a1, unsigned __int8 a2)
{
  int v2; // ebx
  unsigned __int8 *v3; // edx

  v2 = a1[5] - a1[4];
  if ( v2 )
  {
    (*(void (__cdecl **)(_DWORD, _DWORD, int))(*(_DWORD *)(a1[20] + 56) + 8))(a1[20], a1[4], v2);
    a1[5] -= v2;
  }
  v3 = (unsigned __int8 *)a1[5];
  if ( a1[6] <= (unsigned int)v3 )
    return sub_6AB0((int)a1, a2);
  *v3 = a2;
  ++a1[5];
  return a2;
}

//----- (0000767C) --------------------------------------------------------
int __cdecl sub_767C(int a1, int a2, int a3)
{
  int v3; // edi
  int v4; // ebx
  int v6[4]; // [esp+Ch] [ebp-454h] BYREF
  _BYTE *v7; // [esp+1Ch] [ebp-444h]
  _BYTE *v8; // [esp+20h] [ebp-440h]
  _UNKNOWN **v9; // [esp+24h] [ebp-43Ch]
  int v10; // [esp+44h] [ebp-41Ch]
  int v11; // [esp+5Ch] [ebp-404h]
  _BYTE v12[1024]; // [esp+60h] [ebp-400h] BYREF
  _UNKNOWN *retaddr; // [esp+460h] [ebp+0h] BYREF

  v11 = a1;
  v7 = v12;
  v8 = v12;
  v9 = &retaddr;
  v6[0] = -72540156;
  v10 = 60552;
  v3 = sub_775C(v6, a2, a3);
  if ( v8 - v7 <= 0 )
    return v3;
  v4 = v8 - v7;
  if ( (*(int (__cdecl **)(int, _BYTE *, int))(*(_DWORD *)(a1 + 56) + 8))(a1, v7, v8 - v7) == v4 )
    return v3;
  else
    return -1;
}

//----- (0000775C) --------------------------------------------------------
int __cdecl sub_775C(_DWORD *a1, int a2, int a3)
{
  int v3; // ebp
  char *v5; // edx
  int i; // ecx
  char *v7; // ebx
  int v8; // edi
  int v9; // eax
  int v10; // ecx
  int v11; // ebx
  int j; // eax
  int v13; // ecx
  int v14; // ebx
  char *v15; // esi
  char v16; // cl
  unsigned int v17; // edx
  unsigned int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  unsigned int v22; // kr04_4
  char v23; // al
  char *v24; // ebx
  char *v25; // edi
  char *v26; // edi
  int v27; // eax
  int v28; // [esp+20h] [ebp-194h]
  char *v29; // [esp+34h] [ebp-180h]
  int v30; // [esp+38h] [ebp-17Ch]
  int v31; // [esp+3Ch] [ebp-178h]
  int v32; // [esp+40h] [ebp-174h]
  int v33; // [esp+44h] [ebp-170h]
  int v34; // [esp+48h] [ebp-16Ch]
  int v35; // [esp+4Ch] [ebp-168h]
  int v36; // [esp+4Ch] [ebp-168h]
  char *v37; // [esp+50h] [ebp-164h]
  __int16 v38; // [esp+54h] [ebp-160h] BYREF
  char v39; // [esp+57h] [ebp-15Dh] BYREF
  _BYTE v40[348]; // [esp+58h] [ebp-15Ch] BYREF
  _UNKNOWN *retaddr; // [esp+1B4h] [ebp+0h] BYREF

  v3 = a3;
  if ( (*(_BYTE *)a1 & 2) != 0 )
    return sub_767C((int)a1, a2, a3);
  v37 = (char *)a2;
  v33 = 0;
LABEL_4:
  v5 = v37;
  for ( i = *v37; ; i = *v37 )
  {
    v35 = i;
    if ( !i || i == 37 )
      break;
    ++v37;
  }
  v7 = (char *)(v37 - v5);
  if ( v37 != v5 )
  {
    if ( (char *)(*(int (__cdecl **)(_DWORD *, char *, int))(a1[14] + 8))(a1, v5, v37 - v5) != v7 )
      return -1;
    v33 += (int)v7;
  }
  if ( !v35 )
    return v33;
  ++v37;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  v8 = -1;
  v39 = 0;
  while ( 2 )
  {
    v36 = *v37++;
LABEL_14:
    LOWORD(v9) = v36 - 32;
    switch ( v36 )
    {
      case ' ':
        if ( !v39 )
          v39 = 32;
        continue;
      case '#':
        LOBYTE(v34) = v34 | 8;
        continue;
      case '*':
        v3 += 4;
        v10 = *(_DWORD *)(v3 - 4);
        v32 = v10;
        if ( v10 >= 0 )
          continue;
        v32 = -v10;
        goto LABEL_20;
      case '+':
        v39 = 43;
        continue;
      case '-':
LABEL_20:
        LOBYTE(v34) = v34 | 0x10;
        v34 &= ~0x20u;
        continue;
      case '.':
        v36 = *v37++;
        if ( v36 == 42 )
        {
          v3 += 4;
          v8 = *(_DWORD *)(v3 - 4);
          if ( v8 < -1 )
            v8 = -1;
          continue;
        }
        v11 = 0;
        for ( j = v36; (unsigned int)(j - 48) <= 9; j = v36 )
        {
          v11 = v36 + 10 * v11 - 48;
          v36 = *v37++;
        }
        v8 = v11;
        if ( v11 < -1 )
          v8 = -1;
        goto LABEL_14;
      case '0':
        v13 = v34;
        if ( (v34 & 0x10) == 0 )
        {
          LOBYTE(v13) = v34 | 0x20;
          v34 = v13;
        }
        continue;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        v14 = 0;
        do
        {
          v14 = v36 + 10 * v14 - 48;
          v36 = *v37++;
        }
        while ( (unsigned int)(v36 - 48) <= 9 );
        v32 = v14;
        goto LABEL_14;
      case 'D':
        LOBYTE(v34) = v34 | 1;
        goto LABEL_40;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v3 += 8;
        v18 = 0;
        v19 = 32;
        if ( (v34 & 8) != 0 )
          v18 = 256;
        if ( (v34 & 0x10) != 0 )
        {
          LOBYTE(v18) = v18 | 2;
        }
        else if ( (v34 & 0x20) != 0 )
        {
          LOBYTE(v18) = v18 | 8;
          v19 = 48;
        }
        v28 = v19;
        v20 = v8;
        if ( v8 < 0 )
          v20 = 6;
        v21 = sub_8128(v3, *(double *)(v3 - 8), a1, v36, v32, v20, v18, v39, v28);
        if ( v21 < 0 )
          return -1;
        v33 += v21;
        goto LABEL_4;
      case 'L':
        LOBYTE(v34) = v34 | 2;
        continue;
      case 'O':
        LOBYTE(v34) = v34 | 1;
        goto LABEL_62;
      case 'U':
        LOBYTE(v34) = v34 | 1;
        goto LABEL_76;
      case 'X':
      case 'x':
        if ( (v34 & 1) != 0 || (v34 & 4) == 0 )
        {
          v3 += 4;
          v17 = *(_DWORD *)(v3 - 4);
        }
        else
        {
          v3 += 4;
          v17 = *(unsigned __int16 *)(v3 - 4);
        }
        v9 = 2;
        if ( (v34 & 8) != 0 && v17 )
          LOBYTE(v34) = v34 | 0x40;
        goto LABEL_88;
      case 'c':
        v15 = v40;
        v3 += 4;
        v16 = *(_BYTE *)(v3 - 4);
        goto LABEL_108;
      case 'd':
      case 'i':
LABEL_40:
        if ( (v34 & 1) != 0 || (v34 & 4) == 0 )
        {
          v3 += 4;
          v17 = *(_DWORD *)(v3 - 4);
        }
        else
        {
          v3 += 4;
          v17 = *(__int16 *)(v3 - 4);
        }
        if ( (v17 & 0x80000000) != 0 )
        {
          v17 = -v17;
          v39 = 45;
        }
        v9 = 1;
        goto LABEL_89;
      case 'h':
        LOBYTE(v34) = v34 | 4;
        continue;
      case 'l':
        LOBYTE(v34) = v34 | 1;
        continue;
      case 'n':
        if ( (v34 & 1) != 0 || (v34 & 4) == 0 )
        {
          v3 += 4;
          **(_DWORD **)(v3 - 4) = v33;
        }
        else
        {
          v3 += 4;
          **(_WORD **)(v3 - 4) = v33;
        }
        goto LABEL_4;
      case 'o':
LABEL_62:
        if ( (v34 & 1) != 0 || (v34 & 4) == 0 )
        {
          v3 += 4;
          v17 = *(_DWORD *)(v3 - 4);
        }
        else
        {
          v3 += 4;
          v17 = *(unsigned __int16 *)(v3 - 4);
        }
        v9 = 0;
        goto LABEL_88;
      case 'p':
        v3 += 4;
        v17 = *(_DWORD *)(v3 - 4);
        v9 = 2;
        LOBYTE(v34) = v34 | 0x40;
        v36 = 120;
        goto LABEL_88;
      case 's':
        v3 += 4;
        v15 = *(char **)(v3 - 4);
        if ( !v15 )
          v15 = "(null)";
        if ( v8 < 0 )
        {
          v22 = strlen(v15) + 1;
          LOWORD(v9) = v22 - 1;
          v29 = (char *)(v22 - 1);
        }
        else
        {
          v9 = (int)sub_8C0C(v15, 0, v8);
          if ( !v9 || (v9 -= (int)v15, v29 = (char *)v9, v9 > v8) )
            v29 = (char *)v8;
        }
        goto LABEL_109;
      case 'u':
LABEL_76:
        if ( (v34 & 1) != 0 || (v34 & 4) == 0 )
        {
          v3 += 4;
          v17 = *(_DWORD *)(v3 - 4);
        }
        else
        {
          v3 += 4;
          v17 = *(unsigned __int16 *)(v3 - 4);
        }
        v9 = 1;
LABEL_88:
        v39 = 0;
LABEL_89:
        v31 = v8;
        if ( v8 >= 0 )
          LOBYTE(v34) = v34 & 0xDF;
        v15 = (char *)&retaddr;
        if ( v17 || v8 )
        {
          if ( v9 == 1 )
          {
            while ( v17 > 9 )
            {
              --v15;
              v9 = v17 / 0xA;
              *v15 = (v17 % 0xA) | 0x30;
              v17 /= 0xAu;
            }
            *--v15 = v17 + 48;
          }
          else if ( v9 )
          {
            v24 = "0123456789abcdef";
            if ( v36 == 88 )
              v24 = "0123456789ABCDEF";
            do
            {
              --v15;
              v9 = v17 & 0xF;
              *v15 = v24[v9];
              v17 >>= 4;
            }
            while ( v17 );
          }
          else
          {
            do
            {
              --v15;
              v23 = v17 & 7 | 0x30;
              *v15 = v23;
              v17 >>= 3;
            }
            while ( v17 );
            if ( (v34 & 8) != 0 && v23 != 48 )
              *--v15 = 48;
          }
        }
        v29 = (char *)((char *)&retaddr - v15);
        goto LABEL_110;
      default:
        if ( !v36 )
          return v33;
        v15 = v40;
        v16 = v36;
LABEL_108:
        v40[0] = v16;
        v29 = (_BYTE *)(start + 1);
LABEL_109:
        v39 = 0;
LABEL_110:
        v25 = v29;
        v30 = v31 - (_DWORD)v29;
        if ( v31 - (int)v29 < 0 )
          v30 = 0;
        if ( v39 )
        {
          v25 = v29 + 1;
        }
        else if ( (v34 & 0x40) != 0 )
        {
          v25 = v29 + 2;
        }
        v26 = &v25[v30];
        if ( (v34 & 0x30) == 0 )
        {
          v9 = sub_BC04((int)a1, 32, v32 - (_DWORD)v26);
          if ( v9 < v32 - (int)v26 )
            return -1;
        }
        if ( v39 )
        {
          if ( (*(int (__cdecl **)(_DWORD *, char *, int))(a1[14] + 8))(a1, &v39, 1) != 1 )
            return -1;
        }
        else if ( (v34 & 0x40) != 0 )
        {
          LOBYTE(v9) = v36;
          v38 = ((_WORD)v9 << 8) | 0x30;
          if ( (*(int (__cdecl **)(_DWORD *, __int16 *, int))(a1[14] + 8))(a1, &v38, 2) != 2 )
            return -1;
        }
        if ( ((v34 & 0x30) != 0x20 || sub_BC04((int)a1, 48, v32 - (_DWORD)v26) >= v32 - (int)v26)
          && v30 <= sub_BC04((int)a1, 48, v30)
          && v29 == (char *)(*(int (__cdecl **)(_DWORD *, char *, char *))(a1[14] + 8))(a1, v15, v29)
          && ((v34 & 0x10) == 0 || sub_BC04((int)a1, 32, v32 - (_DWORD)v26) >= v32 - (int)v26) )
        {
          v27 = v32;
          if ( v32 < (int)v26 )
            v27 = (int)v26;
          v33 += v27;
          goto LABEL_4;
        }
        return -1;
    }
  }
}
// 7DDD: conditional instruction was optimized away because eax.4==2
// 0: using guessed type void __cdecl __noreturn start(int, int);

//----- (0000806C) --------------------------------------------------------
int __cdecl sub_806C(const char *a1, int a2, int a3)
{
  int v3; // ebx
  _DWORD v5[5]; // [esp+10h] [ebp-5Ch] BYREF
  _BYTE *v6; // [esp+24h] [ebp-48h]
  unsigned int v7; // [esp+28h] [ebp-44h]
  int v8; // [esp+48h] [ebp-24h]

  sub_7010((int)v5, 0);
  v8 = 60616;
  sub_8778(v5, a1, -1, (int)a1);
  v3 = sub_775C(v5, a2, a3);
  if ( v7 > (unsigned int)v6 )
    *v6++ = 0;
  else
    sub_6AB0((int)v5, 0);
  return v3;
}

//----- (000080E0) --------------------------------------------------------
int __cdecl sub_80E0(const char *a1, unsigned __int8 *a2, int a3)
{
  _DWORD v4[23]; // [esp+10h] [ebp-5Ch] BYREF

  sub_7010((int)v4, 0);
  v4[14] = 60616;
  sub_8778(v4, a1, 0, 0);
  return sub_BC9C(v4, a2, a3, 0);
}

//----- (00008128) --------------------------------------------------------
int __usercall sub_8128@<eax>(
        int a1@<ebp>,
        double a2,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        int a8,
        int a9)
{
  int v9; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // et2
  char *v13; // ecx
  int v14; // ebx
  int v15; // ebx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ebp
  int v20; // eax
  int v21; // ebx
  int v22; // esi
  int v23; // eax
  int v24; // esi
  _BYTE *v25; // eax
  int v26; // ebx
  _BYTE *v27; // eax
  _BYTE *v28; // eax
  int v29; // ebx
  int v30; // esi
  int v31; // esi
  _BYTE *v33; // [esp+10h] [ebp-44h]
  char v34; // [esp+14h] [ebp-40h]
  char v35; // [esp+18h] [ebp-3Ch]
  _BYTE *v36; // [esp+1Ch] [ebp-38h]
  char *v37; // [esp+20h] [ebp-34h]
  int v38; // [esp+24h] [ebp-30h]
  int v39; // [esp+28h] [ebp-2Ch]
  char *v40; // [esp+2Ch] [ebp-28h]
  int v41; // [esp+30h] [ebp-24h]
  int v42; // [esp+34h] [ebp-20h]
  int v43; // [esp+38h] [ebp-1Ch]
  int v44; // [esp+3Ch] [ebp-18h] BYREF
  int v45; // [esp+40h] [ebp-14h] BYREF
  int v46[4]; // [esp+44h] [ebp-10h] BYREF
  _UNKNOWN *retaddr; // [esp+54h] [ebp+0h] BYREF

  v9 = a6;
  v10 = 0;
  v43 = a7 & 0xE;
  v42 = 0;
  v41 = (a7 >> 8) & 1;
  v35 = 0;
  switch ( a4 )
  {
    case 'E':
    case 'e':
      v35 = a4;
      a1 = 2;
      if ( a6 == 999 )
        goto LABEL_13;
      v9 = a6 + 1;
      break;
    case 'G':
    case 'g':
      v35 = 69;
      if ( a4 == 103 )
        v35 = 101;
      if ( !a6 )
        v9 = 1;
      if ( (a7 & 0x100) == 0 )
        v42 = 1;
      a4 = 103;
      a1 = 2;
      break;
    case 'f':
      a1 = 3;
      break;
    default:
      break;
  }
  if ( v9 == 999 )
  {
LABEL_13:
    if ( a1 != 3 )
      a1 = 0;
  }
  v37 = sub_AB3C(a2, a1, v9, v46, &v45, &v44);
  v38 = v44 - (_DWORD)v37;
  v36 = &retaddr;
  if ( !a1 )
    v9 = v44 - (_DWORD)v37;
  if ( a1 != 3 && v46[0] != 9999 )
  {
    if ( (v11 = v46[0] - 1, a4 != 103) && a4 != 70 || v11 < -4 || v11 >= v9 )
    {
      if ( v11 < 0 )
      {
        v34 = 45;
        v11 = 1 - v46[0];
      }
      else
      {
        v34 = 43;
      }
      do
      {
        --v36;
        v12 = v11 % 10;
        v11 /= 10;
        *v36 = v12 + 48;
      }
      while ( v11 > 9 );
      *(v36 - 1) = v11 + 48;
      v13 = v36 - 2;
      *v13 = v34;
      v36 -= 3;
      *(v13 - 1) = v35;
    }
  }
  v40 = (char *)((char *)&retaddr - v36);
  if ( a1 == 1 )
    v9 = 1;
  if ( v40 )
    v46[0] = 1;
  if ( v46[0] == 9999 )
  {
    v46[0] = v38;
    v9 = 0;
    v41 = 0;
  }
  if ( v42 )
  {
    v39 = 0;
    goto LABEL_47;
  }
  if ( a4 == 102 )
  {
    v39 = v9;
    if ( v46[0] < v38 )
      v39 = v9 - (v38 - v46[0]);
  }
  else
  {
    if ( v40 || v46[0] < v38 )
      v14 = v9 - v38;
    else
      v14 = v9 - v46[0];
    v39 = v14;
  }
  if ( v39 < 0 )
    v39 = 0;
  if ( !v39 )
  {
LABEL_47:
    if ( v46[0] >= v38 )
      goto LABEL_49;
  }
  v41 = 1;
LABEL_49:
  if ( a8 )
  {
    if ( a8 == 43 )
    {
      v15 = 43;
      if ( v45 )
      {
        v15 = 45;
LABEL_57:
        v16 = (int)&v40[v39 + 1];
        goto LABEL_59;
      }
    }
    else
    {
      v15 = 32;
      if ( v45 )
        v15 = 45;
    }
  }
  else
  {
    v15 = v45 != 0 ? 0x2D : 0;
  }
  if ( v15 )
    goto LABEL_57;
  v16 = (int)&v40[v39];
LABEL_59:
  v17 = v41 + v16;
  if ( v46[0] <= v38 )
  {
    if ( v46[0] > 0 )
      v18 = v17 + v38;
    else
      v18 = v17 + v38 + 1 - v46[0];
  }
  else
  {
    v18 = v17 + v46[0];
  }
  v19 = 0;
  if ( a5 > v18 )
    v19 = a5 - v18;
  if ( v19 > 0 && v43 != 2 && v43 != 8 )
  {
    v10 = v19;
    if ( sub_BC04((int)a3, a9, v19) != v19 )
      return -1;
  }
  if ( v15 )
  {
    v33 = (_BYTE *)a3[5];
    if ( a3[6] > (unsigned int)v33 )
    {
      *v33 = v15;
      v20 = (unsigned __int8)v15;
      ++a3[5];
    }
    else
    {
      v20 = sub_6AB0((int)a3, (unsigned __int8)v15);
    }
    if ( v20 < 0 )
      return -1;
    ++v10;
  }
  if ( v43 != 8 || v19 <= 0 || (v10 += v19, sub_BC04((int)a3, a9, v19) == v19) )
  {
    if ( v46[0] <= 0 )
    {
      v27 = (_BYTE *)a3[5];
      if ( a3[6] > (unsigned int)v27 )
      {
        *v27 = 48;
        ++a3[5];
      }
      else if ( sub_6AB0((int)a3, 48) < 0 )
      {
        return -1;
      }
      v22 = v10 + 1;
      if ( v41 )
      {
        v28 = (_BYTE *)a3[5];
        if ( a3[6] > (unsigned int)v28 )
        {
          *v28 = 46;
          ++a3[5];
        }
        else if ( sub_6AB0((int)a3, 46) < 0 )
        {
          return -1;
        }
        v29 = -v46[0];
        v30 = v22 - v46[0] + 1;
        if ( sub_BC04((int)a3, 48, -v46[0]) != v29 )
          return -1;
        v22 = v38 + v30;
        if ( v38 != (*(int (__cdecl **)(_DWORD *, char *, int))(a3[14] + 8))(a3, v37, v38) )
          return -1;
      }
    }
    else
    {
      if ( v46[0] > v38 )
      {
        v24 = v38 + v10;
        if ( v38 != (*(int (__cdecl **)(_DWORD *, char *, int))(a3[14] + 8))(a3, v37, v38) )
          return -1;
        v21 = v46[0] - v38;
        v22 = v46[0] - v38 + v24;
        v23 = sub_BC04((int)a3, 48, v46[0] - v38);
      }
      else
      {
        v21 = v46[0];
        v22 = v46[0] + v10;
        v23 = (*(int (__cdecl **)(_DWORD *, char *, int))(a3[14] + 8))(a3, v37, v46[0]);
      }
      if ( v23 != v21 )
        return -1;
      if ( v41 )
      {
        v25 = (_BYTE *)a3[5];
        if ( a3[6] > (unsigned int)v25 )
        {
          *v25 = 46;
          ++a3[5];
        }
        else if ( sub_6AB0((int)a3, 46) < 0 )
        {
          return -1;
        }
        ++v22;
        if ( v46[0] < v38 )
        {
          v26 = v38 - v46[0];
          v22 += v38 - v46[0];
          if ( (*(int (__cdecl **)(_DWORD *, char *, int))(a3[14] + 8))(a3, &v37[v46[0]], v38 - v46[0]) != v26 )
            return -1;
        }
      }
    }
    v31 = v39 + v22;
    if ( v39 == sub_BC04((int)a3, 48, v39) )
    {
      if ( !v40
        || (v31 += (int)v40, v40 == (char *)(*(int (__cdecl **)(_DWORD *, _BYTE *, char *))(a3[14] + 8))(a3, v36, v40)) )
      {
        if ( v43 != 2 )
          return v31;
        if ( v19 <= 0 )
          return v31;
        v31 += v19;
        if ( sub_BC04((int)a3, a9, v19) == v19 )
          return v31;
      }
    }
  }
  return -1;
}

//----- (00008778) --------------------------------------------------------
int __cdecl sub_8778(_DWORD *a1, const char *a2, int a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // edx
  int result; // eax

  v4 = a3;
  if ( a3 )
  {
    if ( a3 < 0 )
    {
      v5 = 1024;
      if ( a2 + 1024 >= a2 )
      {
        do
          v5 *= 2;
        while ( v5 > 0 && &a2[v5] > a2 && v5 <= 0x3FFFFFF );
      }
      v4 = v5;
    }
  }
  else
  {
    v4 = strlen(a2);
  }
  result = sub_6CE0((int)a1, (int)a2, (int)&a2[v4], 0);
  a1[4] = a2;
  a1[3] = a2;
  a1[1] = a2;
  if ( a4 )
  {
    a1[5] = a4;
    a1[6] = &a2[v4];
    a1[2] = a4;
  }
  else
  {
    a1[5] = a2;
    a1[6] = a2;
    a1[2] = &a2[v4];
  }
  a1[20] = v4;
  a1[21] = 0;
  return result;
}

//----- (00008828) --------------------------------------------------------
int __cdecl sub_8828(_DWORD *a1, const char *a2, int a3)
{
  int result; // eax

  result = sub_8778(a1, a2, a3, 0);
  *(_BYTE *)a1 |= 8u;
  return result;
}

//----- (00008848) --------------------------------------------------------
int __cdecl sub_8848(int a1, int a2)
{
  unsigned int v2; // edi
  int v3; // ebp
  int v5; // edx
  int v6; // esi
  int v7; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 12);
  if ( (*(_BYTE *)a1 & 8) != 0 )
    return -(a2 != -1);
  if ( *(_DWORD *)(a1 + 80) < v2 )
    *(_DWORD *)(a1 + 80) = v2;
  if ( (*(_DWORD *)a1 & 0xC00) == 0x400 )
  {
    v2 = v3;
    *(_DWORD *)a1 |= 0x800u;
    v3 = *(_DWORD *)(a1 + 80);
  }
  v5 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28);
  if ( __PAIR64__(v2, a2 + 1) >= __PAIR64__(v5, 1) )
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      return -1;
    v7 = 2 * v5;
    v6 = (*(int (__cdecl **)(int))(a1 + 84))(2 * v5);
    if ( !v6 )
      return -1;
    sub_1FC4(v6, *(char **)(a1 + 28), *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
    if ( *(_DWORD *)(a1 + 28) )
    {
      (*(void (__cdecl **)(_DWORD))(a1 + 88))(*(_DWORD *)(a1 + 28));
      *(_DWORD *)(a1 + 28) = 0;
    }
    sub_6CE0(a1, v6, v7 + v6, 1);
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 28) + v2;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 28) + v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 28);
  if ( a2 != -1 )
    *(_BYTE *)(*(_DWORD *)(a1 + 20))++ = a2;
  return a2;
}

//----- (000089E8) --------------------------------------------------------
unsigned int __cdecl sub_89E8(_DWORD *a1)
{
  unsigned int result; // eax

  result = a1[5] - a1[4];
  if ( a1[20] > result )
    return a1[20];
  return result;
}

//----- (00008A08) --------------------------------------------------------
int __cdecl sub_8A08(_DWORD *a1, int a2, char a3)
{
  int v3; // ebx
  unsigned int v4; // ecx
  int result; // eax
  int v6; // edx

  v3 = a2;
  v4 = sub_89E8(a1);
  result = -1;
  v6 = a3 & 3;
  if ( (a3 & 4) == 0 )
  {
    if ( v6 == 1 )
    {
      v3 = a1[1] - a1[3] + a2;
    }
    else if ( v6 == 2 )
    {
      v3 = v4 + a2;
    }
    if ( v3 < 0 || v3 > v4 )
      return -1;
    a1[1] = v3 + a1[3];
    a1[2] = v4 + a1[3];
    result = v3;
  }
  if ( (a3 & 8) == 0 )
  {
    if ( v6 == 1 )
    {
      v3 += a1[5] - a1[4];
    }
    else if ( v6 == 2 )
    {
      v3 += v4;
    }
    if ( v3 < 0 || v3 > v4 )
      return -1;
    a1[5] = v3 + a1[4];
    return v3;
  }
  return result;
}

//----- (00008AE8) --------------------------------------------------------
void __cdecl sub_8AE8(int a1)
{
  if ( *(_DWORD *)(a1 + 28) && (*(_BYTE *)a1 & 1) == 0 )
    (*(void (__cdecl **)(_DWORD))(a1 + 88))(*(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  sub_70A0(a1);
}

//----- (00008B18) --------------------------------------------------------
int __cdecl sub_8B18(int a1)
{
  int v1; // ebx
  int v2; // edx

  v1 = dword_EBE8 + a1;
  dword_EBE8 = sys_brk((void *)(dword_EBE8 + a1));
  if ( dword_EBE8 == v1 )
    return v1 - v2;
  dword_E924 = 12;
  return -1;
}
// 8B4A: variable 'v2' is possibly undefined
// E924: using guessed type int dword_E924;
// EBE8: using guessed type int dword_EBE8;

//----- (00008B50) --------------------------------------------------------
int __cdecl sub_8B50(int a1, char *a2, unsigned int a3)
{
  unsigned int v3; // edx
  char *v4; // edi
  char *v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // ecx
  char *v8; // esi
  _DWORD *v9; // edi
  int v10; // eax
  unsigned int v11; // edx
  _BYTE *v12; // edi
  char *v13; // esi
  int i; // ecx
  _DWORD *v15; // edi
  char *v16; // esi
  unsigned int j; // ecx
  _BYTE *v18; // edi
  char *v19; // esi
  unsigned int k; // ecx

  v3 = a3;
  v4 = (char *)a1;
  v5 = a2;
  if ( a1 - (int)a2 < a3 )
  {
    v8 = &a2[a3];
    v9 = (_DWORD *)(a3 + a1);
    if ( a3 > 7 )
    {
      v10 = (unsigned __int8)v9 & 3;
      v11 = a3 - v10;
      v12 = (char *)v9 - 1;
      v13 = v8 - 1;
      for ( i = v10; i; --i )
        *v12-- = *v13--;
      v15 = v12 - 3;
      v16 = v13 - 3;
      for ( j = v11 >> 2; j; --j )
      {
        *v15 = *(_DWORD *)v16;
        v16 -= 4;
        --v15;
      }
      v9 = v15 + 1;
      v8 = v16 + 4;
      v3 = v11 & 3;
    }
    v18 = (char *)v9 - 1;
    v19 = v8 - 1;
    for ( k = v3; k; --k )
      *v18-- = *v19--;
  }
  else
  {
    if ( a3 > 7 )
    {
      v6 = a3 - (-a1 & 3);
      v7 = -a1 & 3;
      qmemcpy((void *)a1, a2, v7);
      qmemcpy((void *)(a1 + v7), &a2[v7], 4 * (v6 >> 2));
      v5 = &a2[4 * (v6 >> 2) + v7];
      v4 = (char *)(a1 + v7 + 4 * (v6 >> 2));
      v3 = v6 & 3;
    }
    qmemcpy(v4, v5, v3);
  }
  return a1;
}

//----- (00008BD4) --------------------------------------------------------
int __cdecl sub_8BD4(int a1)
{
  int v2; // [esp+0h] [ebp-8h] BYREF
  int v3; // [esp+4h] [ebp-4h] BYREF

  v3 = a1;
  if ( sub_D254(2, (const struct sigaction *)&v3, (struct sigaction *)&v2) >= 0 )
    return v2;
  else
    return -1;
}

//----- (00008C0C) --------------------------------------------------------
_BYTE *__cdecl sub_8C0C(_BYTE *a1, unsigned __int8 a2, int a3)
{
  bool v3; // zf
  int v5; // ecx

  v3 = a3 == 0;
  if ( !a3 )
    return 0;
  v5 = a3;
  do
  {
    if ( !v5 )
      break;
    v3 = *a1++ == a2;
    --v5;
  }
  while ( !v3 );
  if ( !v3 )
    a1 = (_BYTE *)(start + 1);
  return a1 - 1;
}
// 0: using guessed type void __cdecl __noreturn start(int, int);

//----- (00008C40) --------------------------------------------------------
int __cdecl sub_8C40(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 v4; // al
  bool v5; // cf
  int result; // eax

  while ( 1 )
  {
    v4 = *a2++;
    v5 = *a1 < v4;
    if ( *a1++ != v4 )
      break;
    if ( !v4 )
      return 0;
  }
  result = 1;
  if ( !v5 )
    return -1;
  return result;
}

//----- (00008C64) --------------------------------------------------------
int __cdecl sub_8C64(int fd, struct stat *buf)
{
  int result; // eax

  result = sys_newfstat(fd, buf);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00008C88) --------------------------------------------------------
int __cdecl sub_8C88(int fd, off_t offset, int whence)
{
  int result; // eax

  result = sys_lseek(fd, offset, whence);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (00008CC0) --------------------------------------------------------
int __cdecl sub_8CC0(_DWORD *a1)
{
  _BOOL4 v1; // edi
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // eax
  _BYTE v6[8]; // [esp+Ch] [ebp-40h] BYREF
  __int16 v7; // [esp+14h] [ebp-38h]
  int v8; // [esp+24h] [ebp-28h]

  if ( (int)a1[15] >= 0 && (*(int (__cdecl **)(_DWORD *, _BYTE *))(a1[14] + 48))(a1, v6) >= 0 )
  {
    v1 = (v7 & 0xF000) == 0x2000;
    v2 = v8;
    if ( v8 )
      goto LABEL_6;
  }
  else
  {
    v1 = 0;
  }
  v2 = 1024;
LABEL_6:
  v3 = v2;
  if ( !v2 )
    v3 = 1;
  v4 = sub_2378(v3);
  sub_6CE0((int)a1, v4, v2 + v4, 1);
  if ( v1 && sub_D2D4(a1[15]) )
    *a1 |= 0x200u;
  return 1;
}

//----- (00008D5C) --------------------------------------------------------
int __cdecl sub_8D5C(int a1)
{
  *(_WORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 8) = 8;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 14) = 0;
  return a1;
}

//----- (00008D8C) --------------------------------------------------------
int __cdecl sub_8D8C(int a1)
{
  int v1; // ebx
  unsigned int v2; // eax
  int result; // eax

  v1 = a1;
  if ( a1 <= 2 )
    v1 = 3;
  v2 = 4 * (1 << v1) + 20;
  if ( 4 * (1 << v1) == -20 )
    v2 = 1;
  result = sub_2378(v2);
  *(_DWORD *)(result + 4) = v1;
  *(_DWORD *)(result + 8) = 1 << v1;
  *(_DWORD *)(result + 16) = 0;
  *(_WORD *)(result + 14) = 0;
  *(_WORD *)(result + 12) = 0;
  return result;
}

//----- (00008DDC) --------------------------------------------------------
void __cdecl sub_8DDC(int a1)
{
  if ( a1 )
  {
    if ( !*(_WORD *)(a1 + 12) )
      sub_26E8((_DWORD *)a1);
  }
}

//----- (00008DFC) --------------------------------------------------------
_DWORD *__cdecl sub_8DFC(int a1, int a2)
{
  int v2; // ecx
  _DWORD *result; // eax
  _DWORD *i; // edx

  v2 = *(_DWORD *)(a2 + 16);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 14);
  *(_DWORD *)(a1 + 16) = v2;
  result = (_DWORD *)(a1 + 20);
  for ( i = (_DWORD *)(a2 + 20); --v2 >= 0; ++i )
    *result++ = *i;
  return result;
}

//----- (00008E2C) --------------------------------------------------------
int __cdecl sub_8E2C(int a1, int a2)
{
  int v3; // ebx

  if ( !a1 )
    return sub_8D8C(a2);
  if ( *(_DWORD *)(a1 + 4) >= a2 )
    return a1;
  v3 = sub_8D8C(a2);
  sub_8DFC(v3, a1);
  sub_8DDC(a1);
  return v3;
}

//----- (00008E8C) --------------------------------------------------------
int __cdecl sub_8E8C(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // esi
  int v5; // ebp
  unsigned int *v6; // ebx
  unsigned __int16 v7; // cx
  unsigned int v8; // eax
  int v10; // [esp+10h] [ebp-8h]
  unsigned int v11; // [esp+14h] [ebp-4h]

  v3 = (int)a1;
  v5 = a1[4];
  v6 = a1 + 5;
  v10 = 0;
  do
  {
    v7 = a3 + a2 * *v6;
    v8 = ((a3 + a2 * (unsigned __int16)*v6) >> 16) + a2 * HIWORD(*v6);
    a3 = HIWORD(v8);
    *v6++ = v7 | (v8 << 16);
    ++v10;
  }
  while ( v10 < v5 );
  if ( a3 )
  {
    if ( a1[2] <= v5 )
    {
      v11 = HIWORD(v8);
      v3 = sub_8E2C((int)a1, a1[1] + 1);
      a3 = v11;
    }
    *(_DWORD *)(v3 + 4 * v5 + 20) = a3;
    *(_DWORD *)(v3 + 16) = v5 + 1;
  }
  return v3;
}

//----- (00008F1C) --------------------------------------------------------
_DWORD *__cdecl sub_8F1C(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // edx
  int i; // eax
  _DWORD *v8; // edi
  int v9; // esi
  char *v10; // ebx
  char *v11; // ebx
  unsigned int v13; // [esp-4h] [ebp-14h]
  unsigned int v14; // [esp-4h] [ebp-14h]

  v5 = (a4 + 8) / 9;
  v6 = 0;
  for ( i = 1; v5 > i; ++v6 )
    i *= 2;
  v8 = (_DWORD *)sub_8E2C(a1, v6);
  v8[5] = a5;
  v8[4] = 1;
  v9 = 9;
  if ( a3 <= 9 )
  {
    v11 = (char *)(a2 + 10);
  }
  else
  {
    v10 = (char *)(a2 + 9);
    do
    {
      v13 = *v10++ - 48;
      v8 = (_DWORD *)sub_8E8C(v8, 10, v13);
      ++v9;
    }
    while ( v9 < a3 );
    v11 = v10 + 1;
  }
  while ( a4 > v9 )
  {
    v14 = *v11++ - 48;
    v8 = (_DWORD *)sub_8E8C(v8, 10, v14);
    ++v9;
  }
  return v8;
}

//----- (00008FDC) --------------------------------------------------------
int __cdecl sub_8FDC(int a1)
{
  int v1; // edx
  int result; // eax

  v1 = a1;
  result = 0;
  if ( (a1 & 0xFFFF0000) == 0 )
  {
    result = 16;
    v1 = a1 << 16;
  }
  if ( (v1 & 0xFF000000) == 0 )
  {
    result += 8;
    v1 <<= 8;
  }
  if ( (v1 & 0xF0000000) == 0 )
  {
    result += 4;
    v1 *= 16;
  }
  if ( (v1 & 0xC0000000) == 0 )
  {
    result += 2;
    v1 *= 4;
  }
  if ( v1 >= 0 )
  {
    ++result;
    if ( (v1 & 0x40000000) == 0 )
      return 32;
  }
  return result;
}

//----- (0000904C) --------------------------------------------------------
int __cdecl sub_904C(unsigned int *a1)
{
  unsigned int v1; // edx
  int result; // eax

  v1 = *a1;
  if ( (*a1 & 7) != 0 )
  {
    if ( (v1 & 1) != 0 )
    {
      return 0;
    }
    else if ( (v1 & 2) != 0 )
    {
      *a1 = v1 >> 1;
      return 1;
    }
    else
    {
      *a1 = v1 >> 2;
      return 2;
    }
  }
  else
  {
    result = 0;
    if ( !(_WORD)v1 )
    {
      result = 16;
      v1 >>= 16;
    }
    if ( !(_BYTE)v1 )
    {
      result += 8;
      v1 >>= 8;
    }
    if ( (v1 & 0xF) == 0 )
    {
      result += 4;
      v1 >>= 4;
    }
    if ( (v1 & 3) == 0 )
    {
      result += 2;
      v1 >>= 2;
    }
    if ( (v1 & 1) != 0 || (++result, (v1 >>= 1) != 0) )
      *a1 = v1;
    else
      return 32;
  }
  return result;
}

//----- (000090DC) --------------------------------------------------------
int __cdecl sub_90DC(int a1, int a2)
{
  int result; // eax

  result = sub_8E2C(a1, 1);
  *(_DWORD *)(result + 20) = a2;
  *(_DWORD *)(result + 16) = 1;
  return result;
}

//----- (000090FC) --------------------------------------------------------
int __cdecl sub_90FC(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ebx
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // ebp
  _DWORD *v7; // edi
  _DWORD *v8; // edi
  unsigned int *v9; // ebx
  unsigned int v10; // ebp
  unsigned int v11; // esi
  _DWORD *v12; // edi
  unsigned int *v13; // ebx
  unsigned int v14; // ebp
  unsigned int v15; // esi
  _DWORD *i; // ebx
  unsigned int v18; // [esp+14h] [ebp-24h]
  unsigned int v19; // [esp+14h] [ebp-24h]
  unsigned int *v20; // [esp+18h] [ebp-20h]
  unsigned int v21; // [esp+1Ch] [ebp-1Ch]
  _WORD *v22; // [esp+20h] [ebp-18h]
  unsigned int v23; // [esp+24h] [ebp-14h]
  unsigned int v24; // [esp+28h] [ebp-10h]
  _DWORD *v25; // [esp+28h] [ebp-10h]
  int v26; // [esp+2Ch] [ebp-Ch]
  int v27; // [esp+2Ch] [ebp-Ch]
  int v28; // [esp+30h] [ebp-8h]
  int v29; // [esp+34h] [ebp-4h]
  int v30; // [esp+3Ch] [ebp+4h]

  v3 = a2;
  v4 = a3;
  if ( a3[4] > a2[4] )
  {
    v3 = a3;
    v4 = a2;
  }
  v5 = v3[1];
  v6 = v3[4];
  v29 = v4[4];
  v28 = v6 + v29;
  if ( v3[2] < v6 + v29 )
    ++v5;
  v30 = sub_8E2C(a1, v5);
  v7 = (_DWORD *)(v30 + 20);
  v24 = v30 + 20 + 4 * v28;
  if ( v24 > v30 + 20 )
  {
    do
      *v7++ = 0;
    while ( v24 > (unsigned int)v7 );
  }
  v25 = v3 + 5;
  v23 = (unsigned int)&v3[v6 + 5];
  v22 = v4 + 5;
  v21 = (unsigned int)&v4[v29 + 5];
  v20 = (unsigned int *)(v30 + 20);
  if ( (unsigned int)(v4 + 5) < v21 )
  {
    do
    {
      v26 = (unsigned __int16)*v22;
      if ( *v22 )
      {
        v8 = v25;
        v9 = v20;
        v10 = 0;
        do
        {
          v18 = v10 + *(unsigned __int16 *)v9 + v26 * *(unsigned __int16 *)v8;
          v11 = HIWORD(v18) + HIWORD(*v9) + v26 * HIWORD(*v8++);
          v10 = HIWORD(v11);
          *((_WORD *)v9 + 1) = v11;
          *(_WORD *)v9++ = v18;
        }
        while ( v23 > (unsigned int)v8 );
        *v9 = v10;
      }
      v27 = HIWORD(*(_DWORD *)v22);
      if ( v27 )
      {
        v12 = v25;
        v13 = v20;
        v14 = 0;
        v15 = *v20;
        do
        {
          v19 = v14 + HIWORD(*v13) + v27 * *(unsigned __int16 *)v12;
          *((_WORD *)v13 + 1) = v19;
          *(_WORD *)v13++ = v15;
          v15 = HIWORD(v19) + *(unsigned __int16 *)v13 + v27 * HIWORD(*v12++);
          v14 = HIWORD(v15);
        }
        while ( v23 > (unsigned int)v12 );
        *v13 = v15;
      }
      v22 += 2;
      ++v20;
    }
    while ( (unsigned int)v22 < v21 );
  }
  for ( i = (_DWORD *)(v30 + 4 * v28 + 20); v28 > 0; --v28 )
  {
    if ( *--i )
      break;
  }
  *(_DWORD *)(v30 + 16) = v28;
  return v30;
}

//----- (000092CC) --------------------------------------------------------
_DWORD *__cdecl sub_92CC(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int i; // ebx

  result = a1;
  for ( i = a2; i > 6; i -= 6 )
    result = (_DWORD *)sub_8E8C(result, 15625, 0);
  if ( i )
    return (_DWORD *)sub_8E8C(result, dword_ED0C[i], 0);
  return result;
}
// ED0C: using guessed type int dword_ED0C[5];

//----- (0000932C) --------------------------------------------------------
_DWORD *__cdecl sub_932C(_DWORD *a1, int a2)
{
  int v2; // ebx
  int v3; // edx
  int i; // eax
  _DWORD *v6; // ebx
  unsigned int *v7; // esi
  char v8; // bp
  int *v9; // ebx
  int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // [esp+10h] [ebp-10h]
  int v13; // [esp+14h] [ebp-Ch]
  int v14; // [esp+1Ch] [ebp-4h]
  int v15; // [esp+24h] [ebp+4h]

  v2 = a1[4];
  v3 = a1[1];
  v14 = v2 + (a2 >> 5) + 1;
  if ( !a2 )
    return a1;
  for ( i = a1[2]; v14 > i; i *= 2 )
    ++v3;
  v15 = sub_8E2C((int)a1, v3);
  v12 = v15 + 20;
  v6 = (_DWORD *)(v15 + 20 + 4 * v2);
  v7 = &v6[a2 >> 5];
  v8 = a2 & 0x1F;
  if ( (a2 & 0x1F) != 0 )
  {
    v9 = v6 - 1;
    v10 = *v9;
    v11 = (unsigned int)*v9 >> (32 - v8);
    *v7 = v11;
    if ( v11 )
      ++v14;
    while ( v12 < (unsigned int)v9 )
    {
      v13 = *--v9;
      *--v7 = ((unsigned int)*v9 >> (32 - v8)) | (v10 << v8);
      v10 = v13;
    }
    *--v7 = v10 << v8;
  }
  else
  {
    do
      *--v7 = *--v6;
    while ( v12 < (unsigned int)v6 );
  }
  while ( v12 < (unsigned int)v7 )
    *--v7 = 0;
  *(_DWORD *)(v15 + 16) = v14 - 1;
  return (_DWORD *)v15;
}

//----- (0000946C) --------------------------------------------------------
int __cdecl sub_946C(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // eax
  unsigned int *v5; // edx
  unsigned int *v6; // eax
  unsigned int v7; // ecx
  int v8; // edx

  v2 = *(_DWORD *)(a2 + 16);
  result = *(_DWORD *)(a1 + 16) - v2;
  if ( !result )
  {
    v4 = 4 * v2;
    v5 = (unsigned int *)(4 * v2 + a1 + 20);
    v6 = (unsigned int *)(v4 + a2 + 20);
    while ( 1 )
    {
      --v5;
      --v6;
      v7 = *v5;
      if ( *v6 != *v5 )
        break;
      if ( (unsigned int)v5 <= a1 + 20 )
        return 0;
    }
    v8 = 1;
    if ( *v6 > v7 )
      return -1;
    return v8;
  }
  return result;
}

//----- (000094CC) --------------------------------------------------------
int __cdecl sub_94CC(int a1, int a2, int a3)
{
  int *v3; // esi
  int v4; // eax
  int result; // eax
  __int16 v6; // bx
  _DWORD *v7; // esi
  _DWORD *v8; // ebp
  _WORD *v9; // ecx
  int v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // [esp+14h] [ebp-10h]
  int v14; // [esp+14h] [ebp-10h]
  unsigned int v15; // [esp+18h] [ebp-Ch]
  _DWORD *v16; // [esp+1Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp-4h]
  int v18; // [esp+28h] [ebp+4h]

  v3 = (int *)a2;
  v4 = sub_946C(a2, a3);
  if ( v4 )
  {
    if ( v4 >= 0 )
    {
      v6 = 0;
    }
    else
    {
      v3 = (int *)a3;
      a3 = a2;
      v6 = 1;
    }
    v18 = sub_8E2C(a1, v3[1]);
    *(_WORD *)(v18 + 14) = v6;
    v17 = v3[4];
    v7 = v3 + 5;
    v16 = &v7[v17];
    v8 = (_DWORD *)(a3 + 20);
    v15 = a3 + 20 + 4 * *(_DWORD *)(a3 + 16);
    v9 = (_WORD *)(v18 + 20);
    v10 = 0;
    do
    {
      v13 = v10 + *(unsigned __int16 *)v7 - *(unsigned __int16 *)v8;
      v11 = (v13 >> 16) + HIWORD(*v7++) - HIWORD(*v8++);
      v10 = v11 >> 16;
      v9[1] = v11;
      *v9 = v13;
      v9 += 2;
    }
    while ( v15 > (unsigned int)v8 );
    for ( ; v16 > v7; v9 += 2 )
    {
      v14 = v10 + *(unsigned __int16 *)v7;
      v12 = (v14 >> 16) + HIWORD(*v7++);
      v10 = v12 >> 16;
      v9[1] = v12;
      *v9 = v14;
    }
    while ( 1 )
    {
      v9 -= 2;
      if ( *(_DWORD *)v9 )
        break;
      --v17;
    }
    *(_DWORD *)(v18 + 16) = v17;
    return v18;
  }
  else
  {
    result = sub_8E2C(a1, 0);
    *(_DWORD *)(result + 16) = 1;
    *(_DWORD *)(result + 20) = 0;
  }
  return result;
}

//----- (0000965C) --------------------------------------------------------
long double __cdecl sub_965C(int a1, int a2)
{
  int v2; // ecx
  int v3; // ecx
  double v5; // [esp+0h] [ebp-8h]

  if ( (a2 & 0x7FF00000) - 54525952 <= 0 )
  {
    v2 = (54525952 - (a2 & 0x7FF00000)) >> 20;
    if ( v2 > 19 )
    {
      HIDWORD(v5) = 0;
      v3 = v2 - 20;
      if ( v3 > 30 )
        LODWORD(v5) = 1;
      else
        LODWORD(v5) = 1 << (31 - v3);
    }
    else
    {
      HIDWORD(v5) = 0x80000 >> v2;
      LODWORD(v5) = 0;
    }
  }
  else
  {
    HIDWORD(v5) = (a2 & 0x7FF00000) - 54525952;
    LODWORD(v5) = 0;
  }
  return v5;
}

//----- (000096FC) --------------------------------------------------------
long double __cdecl sub_96FC(int a1, _DWORD *a2)
{
  int *v2; // esi
  unsigned int v3; // ebp
  int v4; // eax
  char v5; // di
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ebx
  char v10; // di
  unsigned int v11; // ebp
  unsigned int v13; // [esp+14h] [ebp-Ch]
  double v14; // [esp+18h] [ebp-8h]

  v13 = a1 + 20;
  v2 = (int *)(4 * *(_DWORD *)(a1 + 16) + a1 + 20 - 4);
  v3 = *v2;
  v4 = sub_8FDC(*v2);
  v5 = v4;
  *a2 = 32 - v4;
  if ( v4 > 10 )
  {
    if ( v13 >= (unsigned int)v2 )
      v9 = 0;
    else
      v9 = *--v2;
    v10 = v4 - 11;
    if ( v4 == 11 )
    {
      HIDWORD(v14) = v3 | 0x3FF00000;
      LODWORD(v14) = v9;
      return v14;
    }
    HIDWORD(v14) = (v3 << v10) | (v9 >> (32 - v10)) | 0x3FF00000;
    if ( v13 >= (unsigned int)v2 )
      v11 = 0;
    else
      v11 = *(v2 - 1);
    v7 = v9 << v10;
    v8 = v11 >> (32 - v10);
  }
  else
  {
    HIDWORD(v14) = (v3 >> (11 - v4)) | 0x3FF00000;
    if ( v13 >= (unsigned int)v2 )
      v6 = 0;
    else
      v6 = *(v2 - 1);
    v7 = v3 << (v5 + 21);
    v8 = v6 >> (11 - v5);
  }
  LODWORD(v14) = v8 | v7;
  return v14;
}

//----- (0000980C) --------------------------------------------------------
_DWORD *__cdecl sub_980C(int a1, unsigned int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5; // edi
  unsigned int v6; // ebp
  int v7; // eax
  int v8; // ebx
  unsigned int v9; // eax
  int v10; // eax
  int v12; // [esp+10h] [ebp-14h]
  int v13; // [esp+14h] [ebp-10h]
  unsigned int v14; // [esp+1Ch] [ebp-8h] BYREF
  unsigned int v15; // [esp+20h] [ebp-4h] BYREF

  v5 = (_DWORD *)sub_8E2C(a1, 1);
  v14 = a3 & 0xFFFFF;
  v6 = (a3 & 0x7FFFFFFFu) >> 20;
  if ( v6 )
    v14 |= 0x100000u;
  v15 = a2;
  if ( a2 )
  {
    v7 = sub_904C(&v15);
    v8 = v7;
    if ( v7 )
    {
      v5[5] = v15 | (v14 << (32 - v7));
      v14 >>= v7;
    }
    else
    {
      v5[5] = v15;
    }
    v9 = v14;
    v5[6] = v14;
    v12 = 1;
    if ( v9 )
      v12 = 2;
    v5[4] = v12;
    v13 = v12;
  }
  else
  {
    v10 = sub_904C(&v14);
    v5[5] = v14;
    v5[4] = 1;
    v13 = 1;
    v8 = v10 + 32;
  }
  if ( v6 )
  {
    *a4 = v6 + v8 - 1075;
    *a5 = 53 - v8;
  }
  else
  {
    *a4 = v8 - 1074;
    *a5 = 32 * v13 - sub_8FDC(v5[v13 + 4]);
  }
  return v5;
}

//----- (0000997C) --------------------------------------------------------
long double __cdecl sub_997C(int a1, int a2)
{
  int v2; // eax
  double v4; // [esp+8h] [ebp-18h]
  double v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+18h] [ebp-8h] BYREF
  int v7; // [esp+1Ch] [ebp-4h] BYREF

  v5 = sub_96FC(a1, &v7);
  v4 = sub_96FC(a2, &v6);
  v2 = v7 - v6 + 32 * (*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16));
  if ( v2 <= 0 )
    HIDWORD(v4) -= v2 << 20;
  else
    HIDWORD(v5) += v2 << 20;
  return v5 / v4;
}

//----- (00009A1C) --------------------------------------------------------
long double __cdecl sub_9A1C(_BYTE *a1, _DWORD *a2)
{
  _BYTE *v2; // ebp
  int i; // ebx
  int v4; // ecx
  int v5; // ecx
  int j; // edx
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  _BYTE *v10; // edx
  int v11; // ecx
  long double v12; // fst7
  int v13; // edx
  long double v14; // fst7
  int v15; // ecx
  int v16; // ecx
  int v17; // edx
  double *v18; // eax
  int v19; // ecx
  int v20; // ecx
  int v21; // edx
  double *v22; // eax
  long double v23; // fst7
  long double v24; // fst6
  char v25; // fps^1
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  long double v29; // fst6
  long double v30; // fst6
  char v31; // fps^1
  bool v32; // c0
  char v33; // c2
  bool v34; // c3
  long double v35; // fst7
  int v36; // ecx
  int v37; // ebx
  int v38; // edx
  int v39; // ebx
  int v40; // edx
  int v41; // eax
  int v42; // ebx
  int v43; // eax
  long double v44; // fst7
  long double v45; // fst7
  char v46; // fps^1
  bool v47; // c0
  char v48; // c2
  bool v49; // c3
  long double v50; // fst7
  long double v51; // fst7
  long double v52; // fst6
  long double v53; // fst7
  long double v54; // fst7
  char v55; // fps^1
  bool v56; // c0
  char v57; // c2
  bool v58; // c3
  long double v59; // fst7
  long double v60; // fst7
  char v61; // fps^1
  bool v62; // c0
  char v63; // c2
  bool v64; // c3
  long double result; // fst7
  int v66; // [esp+18h] [ebp-1B8h]
  int v67; // [esp+18h] [ebp-1B8h]
  int v68; // [esp+18h] [ebp-1B8h]
  int v69; // [esp+1Ch] [ebp-1B4h]
  int v70; // [esp+1Ch] [ebp-1B4h]
  unsigned int v71; // [esp+1Ch] [ebp-1B4h]
  long double v72; // [esp+2Ch] [ebp-1A4h]
  long double v73; // [esp+2Ch] [ebp-1A4h]
  _DWORD *v74; // [esp+38h] [ebp-198h]
  int v75; // [esp+3Ch] [ebp-194h]
  _DWORD *v76; // [esp+40h] [ebp-190h]
  int v77; // [esp+44h] [ebp-18Ch]
  _DWORD *v78; // [esp+44h] [ebp-18Ch]
  int v79; // [esp+48h] [ebp-188h]
  _DWORD *v80; // [esp+48h] [ebp-188h]
  _DWORD *v81; // [esp+4Ch] [ebp-184h]
  int v82; // [esp+50h] [ebp-180h]
  int v83; // [esp+54h] [ebp-17Ch]
  int v84; // [esp+58h] [ebp-178h]
  int v85; // [esp+5Ch] [ebp-174h]
  int v86; // [esp+60h] [ebp-170h]
  int v87; // [esp+64h] [ebp-16Ch]
  int v88; // [esp+68h] [ebp-168h]
  int v89; // [esp+6Ch] [ebp-164h]
  int v90; // [esp+70h] [ebp-160h]
  int v91; // [esp+70h] [ebp-160h]
  int v92; // [esp+74h] [ebp-15Ch]
  double v93; // [esp+80h] [ebp-150h]
  int v94; // [esp+88h] [ebp-148h] BYREF
  int v95; // [esp+8Ch] [ebp-144h] BYREF
  double v96; // [esp+90h] [ebp-140h]
  char v97[52]; // [esp+98h] [ebp-138h] BYREF
  char v98[52]; // [esp+CCh] [ebp-104h] BYREF
  char v99[52]; // [esp+100h] [ebp-D0h] BYREF
  char v100[52]; // [esp+134h] [ebp-9Ch] BYREF
  char v101[52]; // [esp+168h] [ebp-68h] BYREF
  char v102[52]; // [esp+19Ch] [ebp-34h] BYREF

  v81 = (_DWORD *)sub_8D5C((int)v102);
  v79 = sub_8D5C((int)v100);
  v77 = sub_8D5C((int)v99);
  v76 = (_DWORD *)sub_8D5C((int)v98);
  v75 = sub_8D5C((int)v101);
  v74 = (_DWORD *)sub_8D5C((int)v97);
  v85 = 0;
  v84 = 0;
  v83 = 0;
  v96 = 0.0;
  v2 = a1;
  while ( 2 )
  {
    if ( (unsigned int)(char)*v2 <= 0x2D )
    {
      switch ( *v2 )
      {
        case 0:
          goto LABEL_6;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 0xE:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x1A:
        case 0x1B:
        case 0x1C:
        case 0x1D:
        case 0x1E:
        case 0x1F:
        case 0x21:
        case 0x22:
        case 0x23:
        case 0x24:
        case 0x25:
        case 0x26:
        case 0x27:
        case 0x28:
        case 0x29:
        case 0x2A:
        case 0x2C:
          goto LABEL_9;
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0x20:
          ++v2;
          continue;
        case 0x2B:
          goto LABEL_5;
        case 0x2D:
          v83 = 1;
LABEL_5:
          if ( *++v2 )
            goto LABEL_9;
LABEL_6:
          v83 = 0;
          break;
      }
      goto LABEL_7;
    }
    break;
  }
LABEL_9:
  if ( *v2 == 48 )
  {
    v84 = 1;
    do
      ++v2;
    while ( *v2 == 48 );
    if ( !*v2 )
      goto LABEL_189;
  }
  v82 = (int)v2;
  v66 = 0;
  v69 = 0;
  v86 = 0;
  for ( i = 0; ; ++i )
  {
    v4 = (char)*v2;
    if ( v4 <= 47 || v4 > 57 )
      break;
    if ( i > 8 )
    {
      if ( i <= 15 )
        v66 = v4 + 10 * v66 - 48;
    }
    else
    {
      v69 = v4 + 10 * v69 - 48;
    }
    ++v2;
  }
  v87 = i;
  if ( v4 == 46 )
  {
    v4 = (char)*++v2;
    if ( i )
      goto LABEL_40;
    for ( ; v4 == 48; v4 = (char)*v2 )
    {
      ++v85;
      ++v2;
    }
    if ( (unsigned int)(v4 - 49) <= 8 )
    {
      v82 = (int)v2;
      v86 = v85;
      v85 = 0;
      do
      {
        ++v85;
        v5 = v4 - 48;
        if ( v5 )
        {
          v86 += v85;
          for ( j = 1; v85 > j; ++j )
          {
            v7 = i++;
            if ( v7 > 8 )
            {
              if ( i <= 16 )
                v66 *= 10;
            }
            else
            {
              v69 *= 10;
            }
          }
          v8 = i++;
          if ( v8 > 8 )
          {
            if ( i <= 16 )
              v66 = v5 + 10 * v66;
          }
          else
          {
            v69 = v5 + 10 * v69;
          }
          v85 = 0;
        }
        v4 = (char)*++v2;
LABEL_40:
        ;
      }
      while ( (unsigned int)(v4 - 48) <= 9 );
    }
  }
  v90 = 0;
  if ( v4 != 101 && v4 != 69 )
    goto LABEL_64;
  if ( !i && !v85 && !v84 )
    goto LABEL_7;
  a1 = v2;
  v89 = 0;
  v9 = (char)*++v2;
  if ( v9 != 43 )
  {
    if ( v9 != 45 )
      goto LABEL_50;
    v89 = 1;
  }
  v9 = (char)*++v2;
LABEL_50:
  if ( (unsigned int)(v9 - 48) > 9 )
  {
    v2 = a1;
  }
  else
  {
    for ( ; v9 == 48; v9 = (char)*v2 )
      ++v2;
    if ( (unsigned int)(v9 - 49) > 8 )
    {
      v90 = 0;
    }
    else
    {
      v90 = v9 - 48;
      v10 = v2;
      while ( 1 )
      {
        v11 = (char)*++v2;
        if ( v11 <= 47 || v11 > 57 )
          break;
        v90 = v11 + 10 * v90 - 48;
      }
      if ( v2 - v10 > 8 )
        v90 = 9999999;
      if ( v89 )
        v90 = -v90;
    }
  }
LABEL_64:
  if ( !i )
  {
    if ( v85 || v84 )
      goto LABEL_189;
LABEL_7:
    v2 = a1;
    goto LABEL_189;
  }
  v91 = v90 - v86;
  if ( !v87 )
    v87 = i;
  v88 = i;
  if ( i > 16 )
    v88 = 16;
  v12 = (long double)(unsigned int)v69;
  v96 = v12;
  if ( v88 > 9 )
    v96 = v12 * dbl_ECE0[v88] + (long double)(unsigned int)v66;
  if ( i <= 15 )
  {
    if ( !v91 )
      goto LABEL_189;
    if ( v91 <= 0 )
    {
      if ( v91 >= -22 )
      {
        v96 = v96 / dbl_ED28[-v91];
        goto LABEL_189;
      }
    }
    else
    {
      if ( v91 <= 22 )
      {
        v96 = v96 * dbl_ED28[v91];
        goto LABEL_189;
      }
      v13 = 15 - i;
      if ( v91 <= 15 - i + 22 )
      {
        v14 = v96 * dbl_ED28[v13];
        v96 = v14;
        v96 = v14 * dbl_ED28[v91 - v13];
        goto LABEL_189;
      }
    }
  }
  v15 = i - v88 + v91;
  if ( v15 <= 0 )
  {
    if ( v15 < 0 )
    {
      v19 = -v15;
      if ( (v19 & 0xF) != 0 )
        v96 = v96 / dbl_ED28[v19 & 0xF];
      LOBYTE(v19) = v19 & 0xF0;
      if ( v19 )
      {
        v20 = v19 >> 4;
        v21 = 0;
        if ( v20 > 1 )
        {
          v22 = dbl_EE08;
          do
          {
            if ( (v20 & 1) != 0 )
              v96 = v96 * *v22;
            ++v22;
            ++v21;
            v20 >>= 1;
          }
          while ( v20 > 1 );
        }
        v23 = v96;
        v24 = v96 * dbl_EE08[v21];
        v96 = v24;
        v26 = v24 > 0.0;
        v27 = 0;
        v28 = 0.0 == v24;
        if ( (v25 & 0x44) == 0x40 )
        {
          v29 = v23 + v23;
          v96 = v29;
          v30 = v29 * dbl_EE08[v21];
          v96 = v30;
          v32 = v30 < 0.0;
          v33 = 0;
          v34 = v30 == 0.0;
          if ( (v31 & 0x44) == 0x40 )
          {
LABEL_110:
            v96 = 0.0;
            dword_E924 = 34;
            goto LABEL_189;
          }
          *(_QWORD *)&v96 = 1;
        }
      }
    }
  }
  else
  {
    if ( (v15 & 0xF) != 0 )
      v96 = v96 * dbl_ED28[v15 & 0xF];
    LOBYTE(v15) = v15 & 0xF0;
    if ( v15 )
    {
      if ( v15 > 308 )
      {
LABEL_88:
        dword_E924 = 34;
        v96 = INFINITY;
        goto LABEL_189;
      }
      v16 = v15 >> 4;
      if ( v16 )
      {
        v17 = 0;
        if ( v16 > 1 )
        {
          v18 = dbl_EDE0;
          do
          {
            if ( (v16 & 1) != 0 )
              v96 = v96 * *v18;
            ++v18;
            ++v17;
            v16 >>= 1;
          }
          while ( v16 > 1 );
        }
        HIDWORD(v96) -= 55574528;
        v96 = v96 * dbl_EDE0[v17];
        if ( (HIDWORD(v96) & 0x7FF00000u) > 0x7CA00000 )
          goto LABEL_88;
        if ( (HIDWORD(v96) & 0x7FF00000u) <= 0x7C900000 )
          HIDWORD(v96) += 55574528;
        else
          v96 = 1.797693134862316e308;
      }
    }
  }
  v78 = sub_8F1C(v77, v82, v87, i, v69);
  v80 = (_DWORD *)sub_8E2C(v79, v78[1]);
  while ( 1 )
  {
    sub_8DFC((int)v80, (int)v78);
    v81 = sub_980C((int)v81, LODWORD(v96), SHIDWORD(v96), &v95, &v94);
    v76 = (_DWORD *)sub_90DC((int)v76, 1);
    if ( v91 < 0 )
    {
      v37 = -v91;
      v36 = -v91;
      v92 = 0;
      v67 = 0;
    }
    else
    {
      v36 = 0;
      v37 = 0;
      v67 = v91;
      v92 = v91;
    }
    if ( v95 < 0 )
      v67 -= v95;
    else
      v37 += v95;
    v70 = v37;
    if ( v94 + v95 - 1 >= -1022 )
      v38 = 54 - v94;
    else
      v38 = v95 + 1075;
    v39 = v38 + v37;
    v68 = v38 + v67;
    v40 = v39;
    if ( v68 < v39 )
      v40 = v68;
    if ( v70 < v40 )
      v40 = v70;
    if ( v40 > 0 )
    {
      v39 -= v40;
      v68 -= v40;
      v70 -= v40;
    }
    if ( v36 > 0 )
    {
      v76 = sub_92CC(v76, v36);
      v41 = sub_90FC(v75, v76, v81);
      v75 = (int)v81;
      v81 = (_DWORD *)v41;
    }
    if ( v39 > 0 )
      v81 = sub_932C(v81, v39);
    if ( v92 > 0 )
      v80 = sub_92CC(v80, v92);
    if ( v68 > 0 )
      v80 = sub_932C(v80, v68);
    if ( v70 > 0 )
      v76 = sub_932C(v76, v70);
    v74 = (_DWORD *)sub_94CC((int)v74, (int)v81, (int)v80);
    v42 = *((__int16 *)v74 + 7);
    *((_WORD *)v74 + 7) = 0;
    v43 = sub_946C((int)v74, (int)v76);
    if ( v43 < 0 )
    {
      if ( v42 )
        goto LABEL_188;
      if ( LODWORD(v96) )
        goto LABEL_188;
      if ( (HIDWORD(v96) & 0xFFFFF) != 0 )
        goto LABEL_188;
      v74 = sub_932C(v74, 1);
      if ( sub_946C((int)v74, (int)v76) <= 0 )
        goto LABEL_188;
LABEL_152:
      HIDWORD(v96) = ((HIDWORD(v96) & 0x7FF00000) - 0x100000) | 0xFFFFF;
      LODWORD(v96) = -1;
      goto LABEL_188;
    }
    if ( !v43 )
      break;
    v50 = sub_997C((int)v74, (int)v76);
    if ( v50 > 2.0 )
    {
      v51 = v50 * 0.5;
      v52 = v51;
      if ( v42 )
        goto LABEL_170;
      goto LABEL_169;
    }
    if ( v42 )
    {
      v51 = 1.0;
      v52 = 1.0;
      goto LABEL_170;
    }
    if ( !LODWORD(v96) && (HIDWORD(v96) & 0xFFFFF) == 0 )
    {
      if ( v50 >= 1.0 )
        v51 = v50 * 0.5;
      else
        v51 = 0.5;
      v52 = v51;
LABEL_169:
      v52 = -v52;
      goto LABEL_170;
    }
    if ( *(_QWORD *)&v96 == 1 )
      goto LABEL_110;
    v51 = 1.0;
    v52 = -1.0;
LABEL_170:
    v71 = HIDWORD(v96) & 0x7FF00000;
    if ( (HIDWORD(v96) & 0x7FF00000) != 0x7FE00000 )
    {
      if ( v71 <= 0x3400000 )
      {
        v56 = v51 > 1.0;
        v57 = 0;
        v58 = 1.0 == v51;
        if ( (unsigned __int8)((v55 & 0x45) - 1) < 0x40u )
        {
          v52 = (long double)(int)(v51 + 0.5);
          if ( !v42 )
            v52 = -v52;
        }
      }
      v73 = v51;
      v59 = sub_965C(SLODWORD(v96), SHIDWORD(v96));
      v96 = v59 * v52 + v96;
      v54 = v73;
      goto LABEL_180;
    }
    v93 = v96;
    HIDWORD(v96) -= 55574528;
    v72 = v51;
    v53 = sub_965C(SLODWORD(v96), SHIDWORD(v96));
    v96 = v53 * v52 + v96;
    v54 = v72;
    if ( (HIDWORD(v96) & 0x7FF00000u) <= 0x7C9FFFFF )
    {
      HIDWORD(v96) += 55574528;
LABEL_180:
      if ( v71 == (HIDWORD(v96) & 0x7FF00000) )
      {
        v60 = v54 - (long double)(int)v54;
        if ( v42 || LODWORD(v96) || (HIDWORD(v96) & 0xFFFFF) != 0 )
        {
          if ( v60 < 0.4999999 )
            goto LABEL_188;
          v62 = v60 > 0.5000000999999999;
          v63 = 0;
          v64 = 0.5000000999999999 == v60;
          if ( (v61 & 0x45) == 1 )
            goto LABEL_188;
        }
        else if ( v60 < 0.24999995 )
        {
          goto LABEL_188;
        }
      }
    }
    else
    {
      if ( v93 == 1.797693134862316e308 )
        goto LABEL_88;
      v96 = 1.797693134862316e308;
    }
  }
  if ( !v42 )
  {
    if ( (HIDWORD(v96) & 0xFFFFF) != 0 || LODWORD(v96) )
      goto LABEL_153;
    goto LABEL_152;
  }
  if ( (HIDWORD(v96) & 0xFFFFF) == 0xFFFFF && LODWORD(v96) == -1 )
  {
    HIDWORD(v96) = (HIDWORD(v96) & 0x7FF00000) + 0x100000;
    LODWORD(v96) = 0;
    goto LABEL_188;
  }
LABEL_153:
  if ( (LOBYTE(v96) & 1) != 0 )
  {
    if ( v42 )
    {
      v35 = sub_965C(SLODWORD(v96), SHIDWORD(v96));
      v96 = v35 + v96;
    }
    else
    {
      v44 = sub_965C(SLODWORD(v96), SHIDWORD(v96));
      v45 = v96 - v44;
      v96 = v45;
      v47 = v45 > 0.0;
      v48 = 0;
      v49 = 0.0 == v45;
      if ( (v46 & 0x45) == 0x40 )
        goto LABEL_110;
    }
  }
LABEL_188:
  sub_8DDC((int)v81);
  sub_8DDC((int)v80);
  sub_8DDC((int)v76);
  sub_8DDC((int)v78);
  sub_8DDC((int)v74);
  sub_8DDC(v75);
LABEL_189:
  if ( a2 )
    *a2 = v2;
  result = v96;
  if ( v83 )
    return -result;
  return result;
}
// A162: variable 'v25' is possibly undefined
// A18F: variable 'v31' is possibly undefined
// A58C: variable 'v46' is possibly undefined
// A73C: variable 'v55' is possibly undefined
// A825: variable 'v61' is possibly undefined
// E924: using guessed type int dword_E924;
// ECE0: using guessed type double dbl_ECE0[5];
// ED28: using guessed type double dbl_ED28[23];
// EDE0: using guessed type double dbl_EDE0[4];
// EE08: using guessed type double dbl_EE08[5];

//----- (0000A8CC) --------------------------------------------------------
unsigned int __cdecl sub_A8CC(int a1, int a2)
{
  unsigned __int16 *v3; // ebx
  _DWORD *v4; // edi
  int v5; // ebp
  unsigned int v6; // edx
  unsigned __int16 v7; // cx
  int v8; // ecx
  int v9; // ebp
  unsigned __int16 *v10; // ebx
  unsigned int v11; // edx
  unsigned int v12; // ecx
  int v13; // ecx
  _DWORD *v14; // edi
  unsigned int v15; // [esp+10h] [ebp-1Ch]
  unsigned int v16; // [esp+10h] [ebp-1Ch]
  unsigned int *v17; // [esp+18h] [ebp-14h]
  unsigned int *v18; // [esp+1Ch] [ebp-10h]
  unsigned int *v19; // [esp+1Ch] [ebp-10h]
  unsigned int v20; // [esp+20h] [ebp-Ch]
  unsigned int v21; // [esp+24h] [ebp-8h]
  unsigned int v22; // [esp+24h] [ebp-8h]
  int v23; // [esp+28h] [ebp-4h]
  int v24; // [esp+28h] [ebp-4h]

  v23 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a1 + 16) < v23 )
    return 0;
  v18 = (unsigned int *)(a2 + 20);
  v24 = v23 - 1;
  v17 = (unsigned int *)(4 * v24 + a2 + 20);
  v3 = (unsigned __int16 *)(a1 + 20);
  v4 = (_DWORD *)(a1 + 20 + 4 * v24);
  v20 = *v4 / (*v17 + 1);
  if ( v20 )
  {
    v5 = 0;
    v21 = 0;
    do
    {
      v6 = *v18++;
      v7 = v20 * v6 + v21;
      v15 = v20 * HIWORD(v6) + ((v20 * (unsigned __int16)v6 + v21) >> 16);
      v21 = HIWORD(v15);
      v8 = v5 + *v3 - v7;
      v5 = ((v8 >> 16) + HIWORD(*(_DWORD *)v3) - (unsigned __int16)v15) >> 16;
      v3[1] = HIWORD(v8) + HIWORD(*(_DWORD *)v3) - v15;
      *v3 = v8;
      v3 += 2;
    }
    while ( v18 <= v17 );
    if ( !*v4 )
    {
      while ( (unsigned int)--v4 > a1 + 20 && !*v4 )
        --v24;
      *(_DWORD *)(a1 + 16) = v24;
    }
  }
  if ( sub_946C(a1, a2) >= 0 )
  {
    ++v20;
    v9 = 0;
    v22 = 0;
    v10 = (unsigned __int16 *)(a1 + 20);
    v19 = (unsigned int *)(a2 + 20);
    do
    {
      v11 = *v19++;
      v12 = (unsigned __int16)v11 + v22;
      v16 = HIWORD(v12) + HIWORD(v11);
      v22 = HIWORD(v16);
      v13 = v9 + *v10 - (unsigned __int16)v12;
      v9 = ((v13 >> 16) + HIWORD(*(_DWORD *)v10) - (unsigned __int16)v16) >> 16;
      v10[1] = HIWORD(v13) + HIWORD(*(_DWORD *)v10) - v16;
      *v10 = v13;
      v10 += 2;
    }
    while ( v19 <= v17 );
    v14 = (_DWORD *)(a1 + 20 + 4 * v24);
    if ( !*v14 )
    {
      while ( (unsigned int)--v14 > a1 + 20 && !*v14 )
        --v24;
      *(_DWORD *)(a1 + 16) = v24;
    }
  }
  return v20;
}

//----- (0000AB3C) --------------------------------------------------------
char *__cdecl sub_AB3C(double a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int v6; // eax
  char *v7; // ebp
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  int v13; // esi
  int v14; // esi
  int v15; // esi
  int v16; // eax
  long double v17; // fst7
  char v18; // fps^1
  long double v19; // fst6
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  char v23; // fps^1
  bool v24; // c0
  char v25; // c2
  bool v26; // c3
  int v27; // edi
  int v28; // ebx
  _BYTE *v29; // ebp
  int v30; // esi
  long double v31; // fst7
  int v32; // ebx
  double *v33; // eax
  int v34; // ecx
  int v35; // ebx
  double *v36; // eax
  long double v37; // fst7
  int v38; // esi
  char v39; // fps^1
  bool v40; // c0
  char v41; // c2
  bool v42; // c3
  char v43; // fps^1
  long double v44; // fst5
  bool v45; // c0
  char v46; // c2
  bool v47; // c3
  int m; // esi
  long double v49; // fst7
  int i; // esi
  int v51; // ebx
  long double v52; // fst6
  char v53; // fps^1
  bool v54; // c0
  char v55; // c2
  bool v56; // c3
  long double v57; // fst6
  char v58; // fps^1
  bool v59; // c0
  char v60; // c2
  bool v61; // c3
  int v62; // ebx
  int v63; // esi
  int v64; // ebx
  int v65; // ebx
  int v66; // eax
  int v67; // esi
  int v68; // eax
  int v69; // ebx
  _DWORD *v70; // eax
  char v71; // si
  int v72; // esi
  int v73; // esi
  int v74; // eax
  int j; // esi
  unsigned int v76; // edi
  int v77; // ebx
  int v78; // eax
  int v79; // eax
  int v80; // esi
  char k; // al
  int v82; // eax
  int v83; // [esp+Ch] [ebp-18Ch]
  int v84; // [esp+Ch] [ebp-18Ch]
  int v85; // [esp+Ch] [ebp-18Ch]
  int v86; // [esp+20h] [ebp-178h]
  _BYTE *v87; // [esp+24h] [ebp-174h]
  _DWORD *v88; // [esp+28h] [ebp-170h]
  _DWORD *v89; // [esp+2Ch] [ebp-16Ch]
  _DWORD *v90; // [esp+30h] [ebp-168h]
  int v91; // [esp+34h] [ebp-164h]
  _DWORD *v92; // [esp+34h] [ebp-164h]
  int v93; // [esp+38h] [ebp-160h]
  int v94; // [esp+3Ch] [ebp-15Ch]
  int v95; // [esp+40h] [ebp-158h]
  int v96; // [esp+44h] [ebp-154h]
  int v97; // [esp+48h] [ebp-150h]
  int v98; // [esp+4Ch] [ebp-14Ch]
  int v99; // [esp+50h] [ebp-148h]
  int v100; // [esp+54h] [ebp-144h]
  int v101; // [esp+58h] [ebp-140h]
  int v102; // [esp+5Ch] [ebp-13Ch]
  int v103; // [esp+60h] [ebp-138h]
  int v104; // [esp+64h] [ebp-134h]
  int v105; // [esp+68h] [ebp-130h]
  int v106; // [esp+6Ch] [ebp-12Ch]
  int v107; // [esp+70h] [ebp-128h]
  double v108; // [esp+74h] [ebp-124h]
  double v109; // [esp+74h] [ebp-124h]
  double v110; // [esp+74h] [ebp-124h]
  double v111; // [esp+84h] [ebp-114h]
  double v112; // [esp+84h] [ebp-114h]
  int v113; // [esp+8Ch] [ebp-10Ch] BYREF
  int v114; // [esp+90h] [ebp-108h] BYREF
  char v115[52]; // [esp+94h] [ebp-104h] BYREF
  char v116[52]; // [esp+C8h] [ebp-D0h] BYREF
  char v117[52]; // [esp+FCh] [ebp-9Ch] BYREF
  char v118[52]; // [esp+130h] [ebp-68h] BYREF
  char v119[52]; // [esp+164h] [ebp-34h] BYREF
  double v120; // [esp+19Ch] [ebp+4h]
  double v121; // [esp+19Ch] [ebp+4h]
  double v122; // [esp+19Ch] [ebp+4h]

  v93 = sub_8D5C((int)v119);
  v91 = sub_8D5C((int)v118);
  v90 = (_DWORD *)sub_8D5C((int)v115);
  v89 = 0;
  v88 = 0;
  if ( dword_EE30 )
  {
    v6 = dword_EE30;
    *(_DWORD *)(dword_EE30 + 4) = dword_EEAC;
    *(_DWORD *)(v6 + 8) = 1 << dword_EEAC;
  }
  if ( a1 >= 0.0 )
  {
    *a5 = 0;
  }
  else
  {
    *a5 = 1;
    HIDWORD(a1) &= ~0x80000000;
  }
  if ( (HIDWORD(a1) & 0x7FF00000) == 0x7FF00000 )
  {
    *a4 = 9999;
    if ( LODWORD(a1) || (HIDWORD(a1) & 0xFFFFF) != 0 )
    {
      v7 = "NaN";
      if ( a6 )
        *a6 = 43759;
    }
    else
    {
      v7 = "Infinity";
      if ( a6 )
        *a6 = 43755;
    }
    return v7;
  }
  v10 = a1 > 0.0;
  v11 = 0;
  v12 = 0.0 == a1;
  if ( (v9 & 0x44) == 0x40 )
  {
    *a4 = 1;
    if ( a6 )
      *a6 = 43761;
    return "0";
  }
  v92 = sub_980C(v91, LODWORD(a1), SHIDWORD(a1), &v114, &v113);
  v13 = (HIDWORD(a1) >> 20) & 0x7FF;
  if ( v13 )
  {
    LODWORD(v111) = LODWORD(a1);
    HIDWORD(v111) = HIDWORD(a1) & 0xFFFFF | 0x3FF00000;
    v14 = v13 - 1023;
    v94 = 0;
  }
  else
  {
    v15 = v114 + v113 + 1074;
    if ( v15 <= 32 )
      v16 = LODWORD(a1) << (32 - v15);
    else
      v16 = (HIDWORD(a1) << (64 - v15)) | (LODWORD(a1) >> (v114 + v113 + 18));
    v111 = (double)(unsigned int)v16;
    HIDWORD(v111) -= 32505856;
    v14 = v114 + v113 - 1;
    v94 = 1;
  }
  v17 = (v111 - 1.5) * 0.289529654602168 + 0.1760912590558 + 0.301029995663981 * (long double)v14;
  v102 = (int)v17;
  if ( v17 < 0.0 )
  {
    v19 = (long double)v102;
    v20 = v19 < v17;
    v21 = 0;
    v22 = v19 == v17;
    if ( (v18 & 0x45) != 0x40 )
      --v102;
  }
  v100 = 1;
  if ( (unsigned int)v102 <= 0x16 )
  {
    v24 = a1 < (long double)dbl_ED28[v102];
    v25 = 0;
    v26 = a1 == dbl_ED28[v102];
    if ( (v23 & 0x45) == 1 )
      --v102;
    v100 = 0;
  }
  if ( v113 - v14 - 1 < 0 )
  {
    v107 = 1 - (v113 - v14);
    v27 = 0;
  }
  else
  {
    v107 = 0;
    v27 = v113 - v14 - 1;
  }
  if ( v102 < 0 )
  {
    v107 -= v102;
    v106 = -v102;
    v97 = 0;
  }
  else
  {
    v106 = 0;
    v97 = v102;
    v27 += v102;
  }
  if ( (unsigned int)a2 > 9 )
    a2 = 0;
  v95 = 1;
  if ( a2 > 5 )
  {
    a2 -= 4;
    v95 = 0;
  }
  v99 = 1;
  switch ( a2 )
  {
    case 0:
    case 1:
      v103 = -1;
      v105 = -1;
      v14 = 18;
      a3 = 0;
      break;
    case 2:
      v99 = 0;
      goto LABEL_44;
    case 3:
      v99 = 0;
      goto LABEL_48;
    case 4:
LABEL_44:
      if ( a3 <= 0 )
        a3 = 1;
      v14 = a3;
      v103 = a3;
      v105 = a3;
      break;
    case 5:
LABEL_48:
      v14 = v102 + a3 + 1;
      v105 = v14;
      v103 = v102 + a3;
      if ( v14 <= 0 )
        v14 = 1;
      break;
    default:
      break;
  }
  v28 = 32;
  dword_EEAC = 3;
  if ( (unsigned int)v14 > 0x33 )
  {
    do
    {
      ++dword_EEAC;
      v28 *= 2;
    }
    while ( v28 + 20 <= (unsigned int)v14 );
  }
  dword_EE30 = sub_8E2C(dword_EE30, dword_EEAC);
  v87 = (_BYTE *)dword_EE30;
  v29 = (_BYTE *)dword_EE30;
  if ( (unsigned int)v105 > 0xE || !v95 )
  {
LABEL_92:
    if ( v114 >= 0 && v102 <= 14 )
    {
      v49 = dbl_ED28[v102];
      if ( a3 >= 0 || v105 > 0 )
      {
        for ( i = 1; ; ++i )
        {
          v51 = (int)(a1 / v49);
          v122 = a1 - v49 * (long double)v51;
          *v29++ = v51 + 48;
          if ( v105 == i )
            break;
          v57 = 10.0 * v122;
          a1 = v57;
          v59 = v57 > 0.0;
          v60 = 0;
          v61 = 0.0 == v57;
          if ( (v58 & 0x45) == 0x40 )
            goto LABEL_221;
        }
        v52 = v122 + v122;
        if ( v52 > v49 )
          goto LABEL_106;
        v54 = v52 < v49;
        v55 = 0;
        v56 = v52 == v49;
        if ( (v53 & 0x44) == 0x40 && (v51 & 1) != 0 )
          goto LABEL_106;
        goto LABEL_221;
      }
      if ( v105 >= 0 && v49 * 5.0 < a1 )
        goto LABEL_167;
      goto LABEL_166;
    }
    v98 = v107;
    v62 = v106;
    if ( v99 )
    {
      if ( a2 > 1 )
      {
        v64 = v105 - 1;
        if ( v106 < v105 - 1 )
        {
          v65 = v64 - v106;
          v97 += v65;
          v106 += v65;
          v62 = 0;
        }
        else
        {
          v62 = v106 - v64;
        }
        v63 = v105;
        if ( v105 < 0 )
        {
          v98 = v107 - v105;
          v63 = 0;
        }
      }
      else if ( v94 )
      {
        v63 = v114 + 1075;
      }
      else
      {
        v63 = 54 - v113;
      }
      v107 += v63;
      v27 += v63;
      v66 = sub_8D5C((int)v117);
      v89 = (_DWORD *)sub_90DC(v66, 1);
    }
    if ( v98 > 0 && v27 > 0 )
    {
      v67 = v98;
      if ( v98 > v27 )
        v67 = v27;
      v107 -= v67;
      v98 -= v67;
      v27 -= v67;
    }
    if ( v106 > 0 )
    {
      if ( !v99 )
      {
        v70 = sub_92CC(v92, v106);
        goto LABEL_134;
      }
      if ( v62 > 0 )
      {
        v89 = sub_92CC(v89, v62);
        v68 = sub_90FC(v93, v89, v92);
        v93 = (int)v92;
        v92 = (_DWORD *)v68;
      }
      v69 = v106 - v62;
      if ( v69 )
      {
        v70 = sub_92CC(v92, v69);
LABEL_134:
        v92 = v70;
      }
    }
    v90 = (_DWORD *)sub_90DC((int)v90, 1);
    if ( v97 > 0 )
      v90 = sub_92CC(v90, v97);
    if ( a2 <= 1 )
    {
      if ( LODWORD(a1) || (HIDWORD(a1) & 0xFFFFF) != 0 || (HIDWORD(a1) & 0x7FF00000) == 0 )
      {
        v96 = 0;
      }
      else
      {
        ++v107;
        ++v27;
        v96 = 1;
      }
    }
    if ( v97 )
      v71 = v27 + 32 - sub_8FDC(v90[v90[4] + 4]);
    else
      v71 = v27 + 1;
    v72 = v71 & 0x1F;
    if ( v72 )
      v72 = 32 - v72;
    if ( v72 <= 4 )
    {
      if ( v72 > 3 )
        goto LABEL_153;
      v73 = v72 + 28;
    }
    else
    {
      v73 = v72 - 4;
    }
    v107 += v73;
    v98 += v73;
    v27 += v73;
LABEL_153:
    if ( v107 > 0 )
      v92 = sub_932C(v92, v107);
    if ( v27 > 0 )
      v90 = sub_932C(v90, v27);
    if ( v100 && sub_946C((int)v92, (int)v90) < 0 )
    {
      --v102;
      v92 = (_DWORD *)sub_8E8C(v92, 10, 0);
      if ( v99 )
        v89 = (_DWORD *)sub_8E8C(v89, 10, 0);
      v105 = v103;
    }
    if ( v105 > 0 || a2 <= 2 )
    {
      if ( v99 )
      {
        if ( v98 > 0 )
          v89 = sub_932C(v89, v98);
        if ( v96 )
        {
          v85 = v89[1];
          v74 = sub_8D5C((int)v116);
          v88 = (_DWORD *)sub_8E2C(v74, v85);
          sub_8DFC((int)v88, (int)v89);
          v89 = sub_932C(v89, 1);
        }
        else
        {
          v88 = v89;
        }
        for ( j = 1; ; ++j )
        {
          v76 = sub_A8CC((int)v92, (int)v90) + 48;
          v77 = sub_946C((int)v92, (int)v88);
          v78 = sub_94CC(v93, (int)v90, (int)v89);
          v93 = v78;
          v86 = *(_WORD *)(v78 + 14) ? 1 : sub_946C((int)v92, v78);
          if ( !v86 && !a2 && (LOBYTE(a1) & 1) == 0 )
            break;
          if ( v77 < 0 || !v77 && !a2 && (LOBYTE(a1) & 1) == 0 )
          {
            if ( v86 <= 0 )
              goto LABEL_193;
            v92 = sub_932C(v92, 1);
            v79 = sub_946C((int)v92, (int)v90);
            if ( v79 <= 0 && (v79 || (v76 & 1) == 0) )
              goto LABEL_193;
            if ( ++v76 != 58 )
              goto LABEL_193;
LABEL_196:
            *v29++ = 57;
            goto LABEL_211;
          }
          if ( v86 > 0 )
          {
            if ( v76 == 57 )
              goto LABEL_196;
            *v29 = v76 + 1;
            goto LABEL_215;
          }
          *v29++ = v76;
          if ( v105 == j )
            goto LABEL_206;
          v92 = (_DWORD *)sub_8E8C(v92, 10, 0);
          if ( v88 == v89 )
          {
            v89 = (_DWORD *)sub_8E8C(v89, 10, 0);
            v88 = v89;
          }
          else
          {
            v88 = (_DWORD *)sub_8E8C(v88, 10, 0);
            v89 = (_DWORD *)sub_8E8C(v89, 10, 0);
          }
        }
        if ( v76 == 57 )
          goto LABEL_196;
        if ( v77 > 0 )
          LOBYTE(v76) = v76 + 1;
LABEL_193:
        *v29 = v76;
      }
      else
      {
        v80 = 1;
        for ( k = sub_A8CC((int)v92, (int)v90); ; k = sub_A8CC((int)v92, (int)v90) )
        {
          LOBYTE(v76) = k + 48;
          *v29++ = k + 48;
          if ( v105 <= v80 )
            break;
          v92 = (_DWORD *)sub_8E8C(v92, 10, 0);
          ++v80;
        }
LABEL_206:
        v92 = sub_932C(v92, 1);
        v82 = sub_946C((int)v92, (int)v90);
        if ( v82 <= 0 && (v82 || (v76 & 1) == 0) )
        {
          do
            --v29;
          while ( *v29 == 48 );
        }
        else
        {
          do
          {
LABEL_211:
            if ( *--v29 != 57 )
            {
              ++*v29;
              goto LABEL_215;
            }
          }
          while ( v87 != v29 );
          ++v102;
          *v87 = 49;
          v29 = v87;
        }
      }
LABEL_215:
      ++v29;
      goto LABEL_216;
    }
    if ( v105 >= 0 )
    {
      v90 = (_DWORD *)sub_8E8C(v90, 5, 0);
      if ( sub_946C((int)v92, (int)v90) > 0 )
        goto LABEL_167;
    }
    goto LABEL_166;
  }
  v112 = a1;
  v101 = v102;
  v104 = v105;
  v30 = 2;
  if ( v102 <= 0 )
  {
    v34 = -v102;
    if ( v102 )
    {
      a1 = a1 * dbl_ED28[v34 & 0xF];
      v35 = v34 >> 4;
      if ( v34 >> 4 )
      {
        v36 = dbl_EDE0;
        do
        {
          if ( (v35 & 1) != 0 )
          {
            ++v30;
            a1 = a1 * *v36;
          }
          v35 >>= 1;
          ++v36;
        }
        while ( v35 );
      }
    }
  }
  else
  {
    v31 = dbl_ED28[v102 & 0xF];
    v32 = v102 >> 4;
    if ( ((v102 >> 4) & 0x10) != 0 )
    {
      v32 = (v102 >> 4) & 0xF;
      a1 = a1 / dbl_EE00;
      v30 = 3;
    }
    if ( v32 )
    {
      v33 = dbl_EDE0;
      do
      {
        if ( (v32 & 1) != 0 )
        {
          ++v30;
          v31 = v31 * *v33;
        }
        v32 >>= 1;
        ++v33;
      }
      while ( v32 );
    }
    a1 = a1 / v31;
  }
  if ( v100 && a1 < 1.0 && v105 > 0 )
  {
    if ( v103 <= 0 )
      goto LABEL_91;
    v105 = v103;
    --v102;
    a1 = 10.0 * a1;
    ++v30;
  }
  v108 = a1 * (long double)v30 + 7.0;
  HIDWORD(v108) -= 54525952;
  if ( !v105 )
  {
    v37 = a1 - 5.0;
    if ( v37 > v108 )
    {
LABEL_167:
      *v29++ = 49;
      ++v102;
LABEL_216:
      sub_8DDC(v93);
      sub_8DDC((int)v90);
      if ( v89 )
      {
        if ( v88 && v88 != v89 )
          sub_8DDC((int)v88);
        sub_8DDC((int)v89);
      }
      goto LABEL_221;
    }
    if ( -v108 > v37 )
    {
LABEL_166:
      v102 = ~a3;
      goto LABEL_216;
    }
    goto LABEL_91;
  }
  if ( v99 )
  {
    v109 = 0.5 / dbl_ED20[v105] - v108;
    v38 = 0;
    while ( 1 )
    {
      v83 = (int)a1;
      v120 = a1 - (long double)v83;
      *v29++ = v83 + 48;
      v40 = v120 < (long double)v109;
      v41 = 0;
      v42 = v120 == v109;
      if ( (v39 & 0x45) == 1 )
        goto LABEL_221;
      v44 = 1.0 - v120;
      v45 = v44 < v109;
      v46 = 0;
      v47 = v44 == v109;
      if ( (v43 & 0x45) == 1 )
        goto LABEL_106;
      if ( v105 <= ++v38 )
        goto LABEL_91;
      v109 = v109 * 10.0;
      a1 = v120 * 10.0;
    }
  }
  v110 = v108 * dbl_ED20[v105];
  for ( m = 1; ; ++m )
  {
    v84 = (int)a1;
    v121 = a1 - (long double)v84;
    *v29++ = v84 + 48;
    if ( v105 == m )
      break;
    a1 = v121 * 10.0;
  }
  if ( v121 > v110 + 0.5 )
  {
LABEL_106:
    while ( *--v29 == 57 )
    {
      if ( v87 == v29 )
      {
        ++v102;
        *v87 = 48;
        break;
      }
    }
    ++*v29++;
    goto LABEL_221;
  }
  if ( 0.5 - v110 <= v121 )
  {
LABEL_91:
    v29 = v87;
    a1 = v112;
    v102 = v101;
    v105 = v104;
    goto LABEL_92;
  }
  do
    --v29;
  while ( *v29 == 48 );
  ++v29;
LABEL_221:
  sub_8DDC((int)v92);
  *v29 = 0;
  *a4 = v102 + 1;
  if ( a6 )
    *a6 = v29;
  return v87;
}
// AC79: variable 'v9' is possibly undefined
// ADF6: variable 'v18' is possibly undefined
// AE31: variable 'v23' is possibly undefined
// B00F: variable 'v105' is possibly undefined
// B132: variable 'v103' is possibly undefined
// B249: variable 'v39' is possibly undefined
// B264: variable 'v43' is possibly undefined
// B46D: variable 'v53' is possibly undefined
// B4E6: variable 'v58' is possibly undefined
// B859: variable 'v96' is possibly undefined
// ED20: using guessed type double dbl_ED20[];
// ED28: using guessed type double dbl_ED28[23];
// EDE0: using guessed type double dbl_EDE0[4];
// EE00: using guessed type double dbl_EE00;
// EE30: using guessed type int dword_EE30;
// EEAC: using guessed type int dword_EEAC;

//----- (0000BC04) --------------------------------------------------------
int __cdecl sub_BC04(int a1, int a2, int a3)
{
  int v3; // esi
  _BYTE *v4; // edi
  int i; // ebx
  int v7; // ebx
  int v8; // eax
  _BYTE v9[16]; // [esp+10h] [ebp-10h] BYREF

  v3 = 0;
  if ( a2 == 32 )
  {
    v4 = (_BYTE *)dword_BBE4;
  }
  else if ( a2 == 48 )
  {
    v4 = (_BYTE *)(dword_BBE4 + 16);
  }
  else
  {
    for ( i = 15; i >= 0; --i )
      v9[i] = a2;
    v4 = v9;
  }
  v7 = a3;
  if ( a3 <= 15 )
  {
LABEL_12:
    if ( v7 > 0 )
      v3 += (*(int (__cdecl **)(int, _BYTE *, int))(*(_DWORD *)(a1 + 56) + 8))(a1, v4, v7);
    return v3;
  }
  else
  {
    while ( 1 )
    {
      v8 = (*(int (__cdecl **)(int, _BYTE *, int))(*(_DWORD *)(a1 + 56) + 8))(a1, v4, 16);
      v3 += v8;
      if ( v8 != 16 )
        return v3;
      v7 -= 16;
      if ( v7 <= 15 )
        goto LABEL_12;
    }
  }
}
// BBE4: using guessed type int[8];

//----- (0000BC9C) --------------------------------------------------------
int __cdecl sub_BC9C(_DWORD *a1, unsigned __int8 *a2, int a3, _BYTE *a4)
{
  int v4; // esi
  int v5; // esi
  unsigned int v6; // ebp
  int v7; // edx
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // esi
  int v12; // ebx
  int j; // eax
  _BYTE *v14; // edi
  _BYTE *v15; // esi
  int v16; // eax
  int m; // edx
  _BYTE *v18; // edi
  _BYTE *v19; // esi
  int k; // edx
  int v21; // edx
  char *v22; // edi
  int v23; // eax
  int v24; // esi
  int v25; // esi
  int *v26; // eax
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // esi
  long double v31; // fst7
  int v33; // [esp+10h] [ebp-284h]
  int v34; // [esp+10h] [ebp-284h]
  _BYTE *v35; // [esp+10h] [ebp-284h]
  int v36; // [esp+14h] [ebp-280h]
  int v37; // [esp+14h] [ebp-280h]
  int v38; // [esp+14h] [ebp-280h]
  int v39; // [esp+14h] [ebp-280h]
  char v40; // [esp+14h] [ebp-280h]
  char v41; // [esp+14h] [ebp-280h]
  int v42; // [esp+14h] [ebp-280h]
  char v43; // [esp+14h] [ebp-280h]
  char v44; // [esp+14h] [ebp-280h]
  char v45; // [esp+14h] [ebp-280h]
  int v46; // [esp+18h] [ebp-27Ch]
  int (__cdecl *v47)(char *, _DWORD, int); // [esp+1Ch] [ebp-278h]
  int v48; // [esp+20h] [ebp-274h]
  int i; // [esp+24h] [ebp-270h]
  int v50; // [esp+28h] [ebp-26Ch]
  char v52; // [esp+34h] [ebp-260h] BYREF
  char v53; // [esp+35h] [ebp-25Fh] BYREF
  _BYTE v54[256]; // [esp+194h] [ebp-100h] BYREF

  v48 = 0;
  v47 = 0;
  v46 = 0;
  v50 = 0;
  for ( i = 0; ; ++i )
  {
    while ( 1 )
    {
LABEL_2:
      v4 = *a2++;
      if ( !v4 )
        goto LABEL_195;
      if ( (off_EAC8[v4] & 0x10) == 0 )
        break;
      while ( 1 )
      {
        if ( a1[2] <= a1[1] && sub_6AD0((int)a1) == -1 )
          v5 = -1;
        else
          v5 = *(unsigned __int8 *)a1[1]++;
        if ( v5 == -1 )
          break;
        if ( (off_EAC8[v5] & 0x10) == 0 )
        {
          sub_D27C(v5, a1);
          goto LABEL_2;
        }
        ++i;
      }
      ++v46;
    }
    if ( v4 == 37 )
      break;
LABEL_16:
    if ( a1[2] <= a1[1] && sub_6AD0((int)a1) == -1 )
      v33 = -1;
    else
      v33 = *(unsigned __int8 *)a1[1]++;
    if ( v33 == -1 )
      goto LABEL_190;
    if ( v33 != v4 )
    {
      sub_D27C(v33, a1);
      goto LABEL_193;
    }
  }
  v6 = 0;
  v7 = 0;
  while ( 2 )
  {
    v4 = *a2++;
    switch ( v4 )
    {
      case 0:
        v50 = -1;
        goto LABEL_195;
      case 37:
        goto LABEL_16;
      case 42:
        if ( v7 )
          goto LABEL_191;
        v7 = 8;
        continue;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        if ( (v7 & 0xFFFFFFB7) != 0 )
          goto LABEL_191;
        LOBYTE(v7) = v7 | 0x40;
        v6 = v4 + 10 * v6 - 48;
        continue;
      case 68:
        goto LABEL_51;
      case 69:
      case 70:
      case 101:
      case 102:
      case 103:
        v8 = 4;
        goto LABEL_54;
      case 76:
        if ( (v7 & 0xFFFFFFB7) != 0 )
          goto LABEL_191;
        LOBYTE(v7) = v7 | 2;
        continue;
      case 79:
        LOBYTE(v7) = v7 | 1;
        goto LABEL_36;
      case 88:
      case 120:
        BYTE1(v7) |= 1u;
        goto LABEL_44;
      case 91:
        v36 = v7;
        a2 = sub_CCCC((int)v54, a2);
        v7 = v36;
        LOBYTE(v7) = v36 | 0x20;
        v8 = 1;
        goto LABEL_54;
      case 99:
        LOBYTE(v7) = v7 | 0x20;
        v8 = 0;
        goto LABEL_54;
      case 100:
        goto LABEL_52;
      case 104:
        if ( (v7 & 0xFFFFFFB7) != 0 )
          goto LABEL_191;
        LOBYTE(v7) = v7 | 4;
        continue;
      case 105:
        v8 = 3;
        v47 = (int (__cdecl *)(char *, _DWORD, int))sub_CD8C;
        v48 = 0;
        goto LABEL_54;
      case 108:
        if ( (v7 & 0xFFFFFFB7) != 0 )
          goto LABEL_191;
        LOBYTE(v7) = v7 | 1;
        continue;
      case 110:
        if ( (v7 & 8) == 0 )
        {
          a3 += 4;
          if ( (v7 & 4) != 0 )
            **(_WORD **)(a3 - 4) = i;
          else
            **(_DWORD **)(a3 - 4) = i;
        }
        goto LABEL_2;
      case 111:
LABEL_36:
        v8 = 3;
        v47 = (int (__cdecl *)(char *, _DWORD, int))sub_D008;
        v48 = 8;
        goto LABEL_54;
      case 112:
        v7 |= 0x110u;
LABEL_44:
        v8 = 3;
        v47 = (int (__cdecl *)(char *, _DWORD, int))sub_D008;
        v48 = 16;
        goto LABEL_54;
      case 115:
        v8 = 2;
        goto LABEL_54;
      case 117:
        v8 = 3;
        v47 = (int (__cdecl *)(char *, _DWORD, int))sub_D008;
        goto LABEL_53;
      default:
        if ( (off_EAC8[v4] & 1) != 0 )
LABEL_51:
          LOBYTE(v7) = v7 | 1;
LABEL_52:
        v8 = 3;
        v47 = (int (__cdecl *)(char *, _DWORD, int))sub_CD8C;
LABEL_53:
        v48 = 10;
LABEL_54:
        if ( a1[2] <= a1[1] )
        {
          v37 = v7;
          v9 = sub_6AD0((int)a1);
          v7 = v37;
          if ( v9 == -1 )
            goto LABEL_190;
        }
        if ( (v7 & 0x20) != 0 || (off_EAC8[*(unsigned __int8 *)a1[1]] & 0x10) == 0 )
          goto LABEL_64;
        break;
    }
    break;
  }
  do
  {
    ++a1[1];
    ++i;
    if ( a1[2] <= a1[1] && (v38 = v7, v10 = sub_6AD0((int)a1), v7 = v38, v10 == -1) )
      v34 = -1;
    else
      v34 = *(unsigned __int8 *)a1[1];
    if ( v34 == -1 )
      goto LABEL_190;
  }
  while ( (off_EAC8[v34] & 0x10) != 0 );
LABEL_64:
  switch ( v8 )
  {
    case 0:
      if ( !v6 )
        v6 = 1;
      if ( (v7 & 8) == 0 )
      {
        a3 += 4;
        if ( (*(int (__cdecl **)(_DWORD *, _DWORD, unsigned int))(a1[14] + 12))(a1, *(_DWORD *)(a3 - 4), v6) != v6 )
          goto LABEL_190;
        i += v6;
        ++v50;
        goto LABEL_2;
      }
      v11 = 0;
      while ( 2 )
      {
        v12 = a1[2] - a1[1];
        if ( v12 >= (int)v6 )
        {
          v11 += v6;
          a1[1] += v6;
LABEL_74:
          i += v11;
          goto LABEL_2;
        }
        v11 += v12;
        v6 -= v12;
        a1[1] = a1[2];
        if ( sub_6AD0((int)a1) != -1 )
          continue;
        break;
      }
      if ( v11 )
      {
        ++v46;
        goto LABEL_74;
      }
LABEL_190:
      ++v46;
LABEL_191:
      if ( !v50 )
        v50 = -1;
LABEL_193:
      if ( a4 )
      {
        *a4 |= 2u;
LABEL_195:
        if ( a4 && v46 )
          *a4 |= 1u;
      }
      return v50;
    case 1:
      if ( !v6 )
        v6 = -1;
      if ( (v7 & 8) != 0 )
      {
        v35 = 0;
        for ( j = *(unsigned __int8 *)a1[1]; ; j = *(unsigned __int8 *)a1[1] )
        {
          if ( !v54[j] )
            goto LABEL_88;
          ++v35;
          ++a1[1];
          if ( !--v6 )
            goto LABEL_88;
          if ( a1[2] <= a1[1] && sub_6AD0((int)a1) == -1 )
            break;
        }
        if ( !v35 )
          goto LABEL_190;
        ++v46;
LABEL_88:
        if ( !v35 )
          goto LABEL_193;
        goto LABEL_110;
      }
      a3 += 4;
      v14 = *(_BYTE **)(a3 - 4);
      v15 = v14;
      v16 = *(unsigned __int8 *)a1[1];
      while ( 2 )
      {
        if ( v54[v16] )
        {
          *v14++ = *(_BYTE *)a1[1]++;
          if ( --v6 )
          {
            if ( a1[2] > a1[1] || sub_6AD0((int)a1) != -1 )
            {
              v16 = *(unsigned __int8 *)a1[1];
              continue;
            }
            if ( v14 == v15 )
              goto LABEL_190;
            ++v46;
          }
        }
        break;
      }
      v35 = (_BYTE *)(v14 - v15);
      if ( v14 == v15 )
        goto LABEL_193;
      *v14 = 0;
      ++v50;
      goto LABEL_110;
    case 2:
      if ( !v6 )
        v6 = -1;
      if ( (v7 & 8) == 0 )
      {
        a3 += 4;
        v18 = *(_BYTE **)(a3 - 4);
        v19 = v18;
        for ( k = *(unsigned __int8 *)a1[1]; ; k = *(unsigned __int8 *)a1[1] )
        {
          if ( (off_EAC8[k] & 0x10) != 0 )
            goto LABEL_118;
          *v18++ = *(_BYTE *)a1[1]++;
          if ( !--v6 )
            goto LABEL_118;
          if ( a1[2] <= a1[1] && sub_6AD0((int)a1) == -1 )
            break;
        }
        ++v46;
LABEL_118:
        *v18 = 0;
        i += v18 - v19;
        ++v50;
        goto LABEL_2;
      }
      v35 = 0;
      for ( m = *(unsigned __int8 *)a1[1]; (off_EAC8[m] & 0x10) == 0; m = *(unsigned __int8 *)a1[1] )
      {
        ++v35;
        ++a1[1];
        if ( !--v6 )
          break;
        if ( a1[2] <= a1[1] && sub_6AD0((int)a1) == -1 )
        {
          ++v46;
          break;
        }
      }
LABEL_110:
      i += (int)v35;
      goto LABEL_2;
    case 3:
      if ( !v6 || v6 > 0x15D )
        v6 = 349;
      v21 = v7 | 0x2C0;
      v22 = &v52;
      while ( 1 )
      {
        switch ( *(_BYTE *)a1[1] )
        {
          case '+':
          case '-':
            if ( (v21 & 0x40) != 0 )
            {
              LOBYTE(v21) = v21 & 0xBF;
              break;
            }
            goto LABEL_144;
          case '0':
            if ( !v48 )
            {
              v48 = 8;
              BYTE1(v21) |= 1u;
            }
            if ( (v21 & 0x200) == 0 )
              goto LABEL_129;
            v21 &= 0xFFFFFD3F;
            break;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
            v48 = word_EE38[v48];
            goto LABEL_129;
          case '8':
          case '9':
            v48 = word_EE38[v48];
            if ( v48 > 8 )
              goto LABEL_129;
            goto LABEL_144;
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            if ( v48 <= 10 )
              goto LABEL_144;
LABEL_129:
            v21 &= 0xFFFFFE3F;
            break;
          case 'X':
          case 'x':
            if ( (v21 & 0x100) == 0 || v22 != &v53 )
              goto LABEL_144;
            v48 = 16;
            BYTE1(v21) &= ~1u;
            break;
          default:
            goto LABEL_144;
        }
        *v22++ = *(_BYTE *)a1[1];
        if ( a1[2] <= ++a1[1] )
        {
          v39 = v21;
          v23 = sub_6AD0((int)a1);
          v21 = v39;
          if ( v23 == -1 )
            break;
        }
        if ( *(unsigned __int8 *)a1[1] == -1 )
          break;
        if ( !--v6 )
          goto LABEL_144;
      }
      ++v46;
LABEL_144:
      if ( (v21 & 0x80u) != 0 )
      {
        if ( v22 > &v52 )
          sub_D27C((unsigned __int8)*(v22 - 1), a1);
        goto LABEL_193;
      }
      v24 = (unsigned __int8)*(v22 - 1);
      if ( v24 == 120 || v24 == 88 )
      {
        --v22;
        v40 = v21;
        sub_D27C(v24, a1);
        LOBYTE(v21) = v40;
      }
      if ( (v21 & 8) != 0 )
        goto LABEL_189;
      *v22 = 0;
      v41 = v21;
      v25 = v47(&v52, 0, v48);
      if ( (v41 & 0x10) != 0 )
        goto LABEL_155;
      if ( (v41 & 4) != 0 )
      {
        a3 += 4;
        **(_WORD **)(a3 - 4) = v25;
      }
      else
      {
        if ( (v41 & 1) != 0 )
        {
LABEL_155:
          a3 += 4;
          v26 = *(int **)(a3 - 4);
        }
        else
        {
          a3 += 4;
          v26 = *(int **)(a3 - 4);
        }
        *v26 = v25;
      }
      goto LABEL_188;
    case 4:
      if ( !v6 || v6 > 0x15D )
        v6 = 349;
      v27 = v7 | 0x3C0;
      v22 = &v52;
      while ( 2 )
      {
        switch ( *(_BYTE *)a1[1] )
        {
          case '+':
          case '-':
            if ( (v27 & 0x40) != 0 )
            {
              LOBYTE(v27) = v27 & 0xBF;
              goto LABEL_170;
            }
            goto LABEL_175;
          case '.':
            if ( (v27 & 0x100) != 0 )
            {
              v27 &= 0xFFFFFEBF;
              goto LABEL_170;
            }
            goto LABEL_175;
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            LOBYTE(v27) = v27 & 0x3F;
            goto LABEL_170;
          case 'E':
          case 'e':
            if ( (v27 & 0x280) != 0x200 )
              goto LABEL_175;
            v28 = v27;
            BYTE1(v28) = BYTE1(v27) & 0xFC;
            v27 = v28;
            LOBYTE(v27) = v28 | 0xC0;
LABEL_170:
            *v22++ = *(_BYTE *)a1[1];
            if ( a1[2] > ++a1[1] || (v42 = v27, v29 = sub_6AD0((int)a1), v27 = v42, v29 != -1) )
            {
              if ( *(unsigned __int8 *)a1[1] != -1 )
              {
                if ( !--v6 )
                  goto LABEL_175;
                continue;
              }
            }
            ++v46;
LABEL_175:
            if ( (v27 & 0x80u) != 0 )
            {
              if ( (v27 & 0x200) != 0 )
              {
                while ( v22 > &v52 )
                  sub_D27C((unsigned __int8)*--v22, a1);
                goto LABEL_193;
              }
              v30 = (unsigned __int8)*--v22;
              if ( v30 != 101 && v30 != 69 )
              {
                v43 = v27;
                sub_D27C(v30, a1);
                v30 = (unsigned __int8)*--v22;
                LOBYTE(v27) = v43;
              }
              v44 = v27;
              sub_D27C(v30, a1);
              LOBYTE(v27) = v44;
            }
            if ( (v27 & 8) == 0 )
            {
              *v22 = 0;
              v45 = v27;
              v31 = sub_9A1C(&v52, 0);
              a3 += 4;
              if ( (v45 & 1) != 0 )
                *(double *)*(_DWORD *)(a3 - 4) = v31;
              else
                **(float **)(a3 - 4) = v31;
LABEL_188:
              ++v50;
            }
LABEL_189:
            i += v22 - &v52;
            break;
          default:
            goto LABEL_175;
        }
        goto LABEL_2;
      }
  }
}
// C268: conditional instruction was optimized away because edi.4<100u
// C2F7: the default case was optimized away because esi.4<5u
// C454: conditional instruction was optimized away because eax.4<100u
// C4E2: conditional instruction was optimized away because eax.4<100u
// C573: conditional instruction was optimized away because edx.4<100u
// C607: conditional instruction was optimized away because edx.4<100u
// C659: conditional instruction was optimized away because ebp.4 is in (1..15D)
// C9C9: conditional instruction was optimized away because ebp.4 is in (1..15D)
// EAC8: using guessed type __int16 *off_EAC8;
// EE38: using guessed type __int16 word_EE38[24];

//----- (0000CCCC) --------------------------------------------------------
unsigned __int8 *__cdecl sub_CCCC(int a1, unsigned __int8 *a2)
{
  int v2; // ecx
  unsigned __int8 *result; // eax
  char v4; // bl
  char *v5; // edx
  char v6; // bl
  int v7; // edx
  int v8; // edx

  v2 = *a2;
  result = a2 + 1;
  if ( v2 == 94 )
  {
    v4 = 1;
    v2 = *result;
    result = a2 + 2;
  }
  else
  {
    v4 = 0;
  }
  v5 = (char *)(a1 + 255);
  do
    *v5-- = v4;
  while ( (int)v5 >= a1 );
  if ( v2 )
  {
    v6 = 1 - v4;
LABEL_9:
    while ( 1 )
    {
      *(_BYTE *)(v2 + a1) = v6;
      while ( 1 )
      {
        v7 = *result++;
        if ( v7 != 45 )
          break;
        v8 = *result;
        if ( v8 == 93 || v8 < v2 )
        {
          v2 = 45;
          goto LABEL_9;
        }
        ++result;
        do
          *(_BYTE *)(++v2 + a1) = v6;
        while ( v2 < v8 );
      }
      if ( v7 <= 45 )
        break;
      if ( v7 == 93 )
        return result;
LABEL_23:
      v2 = v7;
    }
    if ( v7 )
      goto LABEL_23;
  }
  return --result;
}

//----- (0000CD8C) --------------------------------------------------------
int __cdecl sub_CD8C(char *a1, char **a2, int a3)
{
  int v3; // edi
  char *i; // ebx
  unsigned __int8 v5; // al
  int v6; // eax
  unsigned __int8 v7; // al
  int v8; // eax
  unsigned int v9; // esi
  unsigned __int8 j; // al
  unsigned __int8 v11; // al
  int result; // eax
  int v13; // [esp+18h] [ebp-14h]
  char *v14; // [esp+1Ch] [ebp-10h]
  unsigned __int64 v15; // [esp+20h] [ebp-Ch]
  int v16; // [esp+28h] [ebp-4h]

  v3 = a3;
  if ( a3 < 0 || a3 == 1 || a3 > 36 )
    v3 = 10;
  for ( i = a1; (off_EAC8[*i] & 0x10) != 0; ++i )
    ;
  if ( *i )
  {
    if ( *i == 45 )
    {
      v16 = 1;
      ++i;
    }
    else
    {
      v16 = 0;
      if ( *i == 43 )
        ++i;
    }
    if ( v3 == 16 && *i == 48 )
    {
      v5 = i[1];
      v6 = v5 == (char)v5 ? *((unsigned __int8 *)off_EAD0 + v5) : i[1];
      if ( v6 == 88 )
        i += 2;
    }
    if ( !v3 )
    {
      if ( *i == 48 )
      {
        v7 = i[1];
        if ( v7 == (char)v7 )
          v8 = *((unsigned __int8 *)off_EAD0 + v7);
        else
          v8 = i[1];
        if ( v8 == 88 )
        {
          i += 2;
          v3 = 16;
        }
        else
        {
          v3 = 8;
        }
      }
      else
      {
        v3 = 10;
      }
    }
    v14 = i;
    v13 = 0;
    v9 = 0;
    for ( j = *i; *i; j = *++i )
    {
      if ( (off_EAC8[j] & 8) != 0 )
      {
        v11 = j - 48;
      }
      else
      {
        if ( (off_EAC8[j] & 3) == 0 )
          break;
        v11 = *((_BYTE *)off_EAD0 + j) - 55;
      }
      if ( v11 >= v3 )
        break;
      LODWORD(v15) = 0xFFFFFFFF % v3;
      HIDWORD(v15) = 0xFFFFFFFF / v3;
      if ( __PAIR64__(v9, v11) <= v15 )
        v9 = v11 + v3 * v9;
      else
        v13 = 1;
    }
    if ( v14 != i )
    {
      if ( a2 )
        *a2 = i;
      if ( v16 )
      {
        if ( v9 <= 0x80000000 )
        {
LABEL_46:
          if ( v13 )
          {
            dword_E924 = 34;
            result = 0x7FFFFFFF;
            if ( v16 )
              return 0x80000000;
          }
          else
          {
            result = v9;
            if ( v16 )
              return -v9;
          }
          return result;
        }
      }
      else if ( v9 <= 0x7FFFFFFF )
      {
        goto LABEL_46;
      }
      v13 = 1;
      goto LABEL_46;
    }
  }
  if ( a2 )
    *a2 = a1;
  return 0;
}
// E924: using guessed type int dword_E924;
// EAC8: using guessed type __int16 *off_EAC8;
// EAD0: using guessed type int (*off_EAD0)[67];

//----- (0000D008) --------------------------------------------------------
int __cdecl sub_D008(char *a1, char **a2, int a3)
{
  int v3; // edi
  char *i; // ebx
  unsigned __int8 v5; // al
  int v6; // eax
  unsigned __int8 v7; // al
  int v8; // eax
  int v9; // esi
  unsigned __int8 j; // al
  unsigned __int8 v11; // al
  int result; // eax
  int v13; // [esp+18h] [ebp-14h]
  char *v14; // [esp+1Ch] [ebp-10h]
  unsigned __int64 v15; // [esp+20h] [ebp-Ch]
  int v16; // [esp+28h] [ebp-4h]

  v3 = a3;
  if ( a3 < 0 || a3 == 1 || a3 > 36 )
    v3 = 10;
  for ( i = a1; (off_EAC8[*i] & 0x10) != 0; ++i )
    ;
  if ( !*i )
    goto LABEL_46;
  if ( *i == 45 )
  {
    v16 = 1;
    ++i;
  }
  else
  {
    v16 = 0;
    if ( *i == 43 )
      ++i;
  }
  if ( v3 == 16 && *i == 48 )
  {
    v5 = i[1];
    v6 = v5 == (char)v5 ? *((unsigned __int8 *)off_EAD0 + v5) : i[1];
    if ( v6 == 88 )
      i += 2;
  }
  if ( !v3 )
  {
    if ( *i == 48 )
    {
      v7 = i[1];
      if ( v7 == (char)v7 )
        v8 = *((unsigned __int8 *)off_EAD0 + v7);
      else
        v8 = i[1];
      if ( v8 == 88 )
      {
        i += 2;
        v3 = 16;
      }
      else
      {
        v3 = 8;
      }
    }
    else
    {
      v3 = 10;
    }
  }
  v14 = i;
  v13 = 0;
  v9 = 0;
  for ( j = *i; *i; j = *++i )
  {
    if ( (off_EAC8[j] & 8) != 0 )
    {
      v11 = j - 48;
    }
    else
    {
      if ( (off_EAC8[j] & 3) == 0 )
        break;
      v11 = *((_BYTE *)off_EAD0 + j) - 55;
    }
    if ( v11 >= v3 )
      break;
    LODWORD(v15) = 0xFFFFFFFF % v3;
    HIDWORD(v15) = 0xFFFFFFFF / v3;
    if ( __PAIR64__(v9, v11) <= v15 )
      v9 = v11 + v3 * v9;
    else
      v13 = 1;
  }
  if ( v14 == i )
  {
LABEL_46:
    if ( a2 )
      *a2 = a1;
    return 0;
  }
  else
  {
    if ( a2 )
      *a2 = i;
    if ( v13 )
    {
      dword_E924 = 34;
      return -1;
    }
    else
    {
      result = v9;
      if ( v16 )
        return -v9;
    }
  }
  return result;
}
// E924: using guessed type int dword_E924;
// EAC8: using guessed type __int16 *off_EAC8;
// EAD0: using guessed type int (*off_EAD0)[67];

//----- (0000D254) --------------------------------------------------------
int __cdecl sub_D254(int how, const struct sigaction *act, struct sigaction *oldact)
{
  int result; // eax

  result = sys_sigprocmask(how, act, oldact);
  if ( result < 0 )
  {
    dword_E924 = -result;
    return -1;
  }
  return result;
}
// E924: using guessed type int dword_E924;

//----- (0000D27C) --------------------------------------------------------
int __cdecl sub_D27C(int a1, _DWORD *a2)
{
  if ( a2 && (*a2 & 0xFFFF0000) == 0xFBAD0000 )
  {
    if ( a1 == -1 )
      return -1;
    else
      return sub_7100(a2, (unsigned __int8)a1);
  }
  else
  {
    dword_E924 = 5;
    return -1;
  }
}
// E924: using guessed type int dword_E924;

//----- (0000D2D4) --------------------------------------------------------
_BOOL4 __cdecl sub_D2D4(int d)
{
  int v1; // ebx
  _BOOL4 result; // eax

  v1 = dword_E924;
  result = sub_D308(d) == 0;
  dword_E924 = v1;
  return result;
}
// E924: using guessed type int dword_E924;

//----- (0000D308) --------------------------------------------------------
int __cdecl sub_D308(int d)
{
  return sub_55B8(d, 21505);
}

// nfuncs=190 queued=187 decompiled=187 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 187 function(s)"

